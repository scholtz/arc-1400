# ARC-1410: Partitioned Token Balances (Draft)

Status: Draft  
Category: Standard Track  
Created: 2025-09-03  
Part of: ARC-1400 Suite  
Depends On: ARC-1594  
Author(s): Ludovit Scholtz

## 1. Abstract

ARC-1410 defines partitioned balances for Algorand security tokens. Partitions allow segregating holdings (e.g., unrestricted, locked, escrow, tranche A/B) while preserving a single ARC-200 token supply. Each partition acts as a logical sub-ledger with rules influencing transfer eligibility.

## 2. Motivation

Regulated assets often require lock-ups and categorization of units. Instead of deploying multiple ARC-200 tokens, partitions provide granular control, improved UX, and simplified corporate actions (single total supply). Ethereum's ERC-1410 informs this ARC; we adapt to Algorand state constraints and atomic group mechanics.

## 3. Specification

### 3.1 Partition Identifier

A partition is identified by an ARC-4 `address` (not a 32-byte arbitrary hash). Divergence from ERC-1410: Ethereum permits `bytes32` (or shorter labels hashed); ARC-1410 fixes the identifier to an address to enable:

- Native authorization (partition controller / escrow account as identifier)
- Reuse of address indexing infra
- Clear zero-address semantics for the default/unrestricted partition

Implementations MAY map human-readable labels to partition addresses via a registry box `partition-labels` storing tuples `(label -> address)`.

### 3.2 State Representation

Two recommended models:

1. Local State Mapping: Each account's local state stores per-partition balances under truncated keys (e.g., first 8 bytes of partition address) when partition count is small (<8 due to schema limits).
2. Boxes: Each holder has a box named `p-<addr>-<partitionAddr>` storing a `uint64` balance (msgpack encoded). Preferred for scalable partition counts.

A global box `partitions` MAY store an indexed list of active partition addresses and optional metadata (label, flags).

### 3.3 Invariants

For every account: `Î£ partitionBalances == ARC-200 balance`. Contract logic MUST enforce this on issuance, redemption, and transfers. Discrepancies MUST trigger failure.

### 3.4 Methods (ABI Recommendations)

(All snake_case with ARC-4 types; `partition: address`.)

- `balance_of_partition(holder: address, partition: address) -> (amount: uint64)`
- `partitions_of(holder: address) -> (partitions: address[])` (MAY paginate if large)
- `transfer_by_partition(from: address, to: address, partition: address, amount: uint64, data: bytes) -> (code: uint64, reason: bytes)`
- `issue_by_partition(to: address, partition: address, amount: uint64, data: bytes)`
- `redeem_by_partition(from: address, partition: address, amount: uint64, data: bytes)`
- `set_partition_flag(partition: address, flag_key: bytes, value: uint64)`

### 3.5 Transfer Semantics

`transfer_by_partition` MUST internally call or replicate ARC-1594 validation logic including partition-specific flags:

- Transferable flag absent or zero -> return code `12` PartitionRestricted.
- Check sender partition balance.
- Adjust sender + recipient partition balances atomically with ARC-200 movement (inner transaction or paired ARC-200 transfer).

If `partition` is the zero address it denotes the default/unrestricted partition when such a concept is used.

### 3.6 Discovery

Wallets & indexers discover partitions via:

1. Reading global `partitions` box.
2. Querying `partitions_of`.

### 3.7 Events (Logs)

- Tag 0x11 partition_transfer | from | to | partition(address) | amount
- Tag 0x12 partition_issue | to | partition(address) | amount
- Tag 0x13 partition_redeem | from | partition(address) | amount

### 3.8 Merging / Splitting

Optional methods MAY allow migrating balances between partitions with issuer authorization (e.g., releasing locked units).

### 3.9 Cost Considerations

Use boxes to avoid local state schema inflation for large partition sets. Batch operations (e.g., multi-partition redemption) can be structured as multiple app calls in a group.

## 4. Security Considerations

- Prevent creation of unauthorized partitions (maintain an allowlist of partition addresses).
- Avoid address reuse for unrelated semantic partitions without proper migration flows.
- Ensure merging logic cannot bypass lock-ups (validate destination partition flags).

## 5. Reference Implementation

Planned in `smart_contracts/security_token` module.

## 6. Backwards Compatibility

Applications not aware of partitions can treat the zero address partition as canonical, reading ARC-200 balance minus sum of restricted partitions if exposed.

## 7. Copyright

CC0 1.0 Universal.
