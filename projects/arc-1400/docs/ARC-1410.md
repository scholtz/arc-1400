# ARC-1410: Partitioned Token Balances (Draft)

Status: Draft  
Category: Standard Track  
Created: 2025-09-03  
Part of: ARC-1400 Suite  
Depends On: ARC-1594  
Author(s): <your-name / org>

## 1. Abstract

ARC-1410 defines partitioned balances for Algorand security tokens. Partitions allow segregating holdings (e.g., unrestricted, locked, escrow, tranche A/B) while preserving a single ARC-200 token supply. Each partition acts as a logical sub-ledger with rules influencing transfer eligibility.

## 2. Motivation

Regulated assets often require lock-ups and categorization of units. Instead of deploying multiple ARC-200 tokens, partitions provide granular control, improved UX, and simplified corporate actions (single total supply). Ethereum's ERC-1410 informs this ARC; we adapt to Algorand state constraints and atomic group mechanics.

## 3. Specification

### 3.1 Partition Identifier

A partition is identified by a 32-byte value (`bytes32`) or a shorter canonical ASCII label hashed (e.g., `keccak256(label)` or Blake2b). Implementations SHOULD expose a registry mapping human-readable labels to raw keys.

### 3.2 State Representation

Two recommended models:

1. Local State Mapping: Each account's local state stores per-partition balances under truncated keys (e.g., first 8 bytes of hash) when partition count is small (<8 due to schema limits).
2. Boxes: Each holder has a box named `p-<addr>-<partitionHash>` storing a `uint64` balance (msgpack encoded). Preferred for scalable partition counts.

A global box `partitions` MAY store an indexed list of active partition keys and optional metadata (label, flags).

### 3.3 Invariants

For every account: `Σ partitionBalances == ARC-200 balance`. Contract logic MUST enforce this on issuance, redemption, and transfers. Discrepancies MUST trigger failure.

### 3.4 Methods (ABI Recommendations)

(All snake_case with ARC-4 types.)

- `balance_of_partition(holder: address, partition: bytes32) -> (amount: uint64)`
- `partitions_of(holder: address) -> (partitions: bytes[])` (MAY paginate if large)
- `transfer_by_partition(from: address, to: address, partition: bytes32, amount: uint64, data: bytes) -> (code: uint64, reason: bytes)`
- `issue_by_partition(to: address, partition: bytes32, amount: uint64, data: bytes)`
- `redeem_by_partition(from: address, partition: bytes32, amount: uint64, data: bytes)`
- `set_partition_flag(partition: bytes32, flag_key: bytes, value: uint64)`

### 3.5 Transfer Semantics

`transfer_by_partition` MUST internally call or replicate ARC-1594 validation logic including partition-specific flags:

- Transferable flag absent or zero -> return code `12` PartitionRestricted.
- Check sender partition balance.
- Adjust sender + recipient partition balances atomically with ARC-200 movement (inner transaction or paired ARC-200 transfer).

### 3.6 Discovery

Wallets & indexers discover partitions via:

1. Reading global `partitions` box.
2. Querying `partitions_of`.

### 3.7 Events (Logs)

- Tag 0x11 partition_transfer | from | to | partition | amount
- Tag 0x12 partition_issue | to | partition | amount
- Tag 0x13 partition_redeem | from | partition | amount

### 3.8 Merging / Splitting

Optional methods MAY allow migrating balances between partitions with issuer authorization (e.g., releasing locked units).

### 3.9 Cost Considerations

Use boxes to avoid local state schema inflation for large partition sets. Batch operations (e.g., multi-partition redemption) can be structured as multiple app calls in a group.

## 4. Security Considerations

- Prevent creation of unauthorized partitions (maintain an allowlist).
- Avoid hash collisions—use full 32 bytes in boxes even if truncated keys appear in local state.
- Ensure merging logic cannot bypass lock-ups (validate destination partition flags).

## 5. Reference Implementation

Planned in `smart_contracts/security_token` module.

## 6. Backwards Compatibility

Applications not aware of partitions can treat unrestricted partition as canonical, reading ARC-200 balance minus sum of restricted partitions if exposed.

## 7. Copyright

CC0 1.0 Universal.
