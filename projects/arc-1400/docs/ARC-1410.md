# ARC-1410: Partitioned Token Balances (Draft)

Status: Draft  
Category: Standard Track  
Created: 2025-09-03  
Part of: ARC-1400 Suite  
Depends On: ARC-1594  
Author(s): <your-name / org>

## 1. Abstract

ARC-1410 defines partitioned balances for Algorand security tokens. Partitions allow segregating holdings (e.g., unrestricted, locked, escrow, tranche A/B) while preserving a single ASA. Each partition acts as a logical sub-ledger with rules influencing transfer eligibility.

## 2. Motivation

Regulated assets often require lock-ups and categorization of units. Instead of deploying multiple ASAs, partitions provide granular control, improved UX, and simplified corporate actions (single total supply). Ethereum's ERC-1410 informs this ARC; we adapt to Algorand state constraints and atomic group mechanics.

## 3. Specification

### 3.1 Partition Identifier

A partition is identified by a 32-byte value (`byte[32]`) or a shorter canonical ASCII label hashed (e.g., `keccak256(label)` or Blake2b). Implementations SHOULD expose a registry mapping human-readable labels to raw keys.

### 3.2 State Representation

Two recommended models:

1. Local State Mapping: Each account's local state stores per-partition balances under truncated keys (e.g., first 8 bytes of hash) when partition count is small (<8 due to schema limits).
2. Boxes: Each holder has a box named `p-<addr>-<partitionHash>` storing a `uint64` balance (msgpack encoded). Preferred for scalable partition counts.

A global box `partitions` MAY store an indexed list of active partition keys and optional metadata (label, flags).

### 3.3 Invariants

For every account: `Σ partitionBalances == ASA balance`. Contract logic MUST enforce this on issuance, redemption, and transfers. Discrepancies MUST trigger failure.

### 3.4 Methods (ABI Recommendations)

- `BalanceOfPartition(holder, partition) -> amount:uint64`
- `PartitionsOf(holder) -> partitions:byte[][]`
- `TransferByPartition(from, to, partition, amount, data:byte[]) -> (code:uint64, reason:byte[])`
- `IssueByPartition(to, partition, amount, data:byte[])`
- `RedeemByPartition(from, partition, amount, data:byte[])`
- `SetPartitionFlag(partition, flagKey:byte[], value:uint64)` (e.g., transferable=1)

### 3.5 Transfer Semantics

`TransferByPartition` MUST internally call or replicate ARC-1594 validation logic including partition-specific flags:

- Transferable flag absent or zero -> return code `12` PartitionRestricted.
- Check sender partition balance.
- Adjust sender + recipient partition balances atomically with ASA movement (inner transaction or paired ASA transfer).

### 3.6 Discovery

Wallets & indexers discover partitions via:

1. Reading global `partitions` box.
2. Querying `PartitionsOf(holder)`.

### 3.7 Events (Logs)

- Tag 0x11 PartitionTransfer | from | to | partition | amount
- Tag 0x12 PartitionIssue | to | partition | amount
- Tag 0x13 PartitionRedeem | from | partition | amount

### 3.8 Merging / Splitting

Optional methods MAY allow migrating balances between partitions with issuer authorization (e.g., releasing locked units).

### 3.9 Gas / Cost Considerations

Use boxes to avoid local state schema inflation for large partition sets. Batch operations (e.g., multi-partition redemption) can be structured as multiple app calls in a group.

## 4. Security Considerations

- Prevent creation of unauthorized partitions (maintain an allowlist).
- Avoid hash collisions—use full 32 bytes in boxes even if truncated keys appear in local state.
- Ensure merging logic cannot bypass lock-ups (validate destination partition flags).

## 5. Reference Implementation

Planned in `smart_contracts/security_token` module.

## 6. Backwards Compatibility

Applications not aware of partitions can treat unrestricted partition as canonical, reading ASA balance minus sum of restricted partitions if exposed.

## 7. Copyright

CC0 1.0 Universal.
