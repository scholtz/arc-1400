# ARC-1400: Security Token Standard Suite (Draft)

Status: Draft  
Category: Standard Track  
Created: 2025-09-03  
Requires: ARC-1594, ARC-1410, ARC-1643, ARC-1644  
Replaces / Aggregates: ERC-1400 (Ethereum)  
Author(s): Ludovit Scholtz

## 1. Abstract

ARC-1400 defines a composable suite of Algorand smart contract application layer specifications enabling compliant issuance, partitioned holdings, document disclosure, and controller / regulatory actions for tokenized securities. It adapts the semantics of the Ethereum ERC-1400 family (ERC-1594, ERC-1410, ERC-1643, ERC-1644) to Algorand primitives including ARC-200 (ERC-20 port), smart contract global/local state, boxes, logic signatures, and rekeyed multi-signature governance accounts.

## 2. Motivation

Security tokens require:

- Transfer restriction checks (jurisdiction, KYC/AML, lock-up) with informative rejections.
- Partitioned balances (e.g., unrestricted, restricted, escrow, tranches) with atomic transfer semantics.
- Off-chain document disclosure with on-chain integrity proofs.
- Regulator / controller powers for forced transfers, seizures, or redemptions under predefined governance.

On Ethereum these are expressed via a set of interfaces across multiple ERCs composing ERC-1400. Algorand's architecture (ARC-200 base fungible token primitive plus AVM smart contracts) provides distinct affordances: fast finality, stateless/stateful TEAL, and logic signature / rekey features. ARC-1400 maps required behaviors into deterministic AVM logic while minimizing transaction overhead and preserving auditability.

## 3. Specification Overview

ARC-1400 is an umbrella designation; compliance implies conformance with the component ARCs it aggregates:

- ARC-1594 (Core Security Token Operations & Transfer Validation)
- ARC-1410 (Partitioned Balances)
- ARC-1643 (Document Registry)
- ARC-1644 (Controller Operations)

An implementation MAY provide a unified application (single App ID) coordinating all modules, or deploy multiple composable applications with standardized ABI method names and box/global state keys.

## 4. Roles

- Issuer: Originates and manages supply, documents, compliance data.
- Controller: Authorized entity (could be same as Issuer) with limited override powers (ARC-1644).
- Investor: Holder of ARC-200 units.
- Registrar / Compliance Oracle: Off-chain / on-chain service that signs or writes eligibility data (e.g., KYC flags, jurisdiction codes) into contract state.
- Document Provider: Pushes document hashes / URIs (ARC-1643).
- Governance Multisig: Rekeyed address or LogicSig controlling privileged calls.

## 5. Algorand Mapping

| Concept            | Ethereum (ERC-1400)                   | Algorand (ARC-1400)                                                                       |
| ------------------ | ------------------------------------- | ----------------------------------------------------------------------------------------- |
| Token Units        | ERC-20 ledger                         | ARC-200                                                                                   |
| Partition Balances | Mapped in contract storage            | Boxes (partition -> uint balance) per holder or local state schema                        |
| Transfer Pre-Check | Smart contract hook or off-chain call | Group transaction including App call performing eligibility logic before ARC-200 transfer |
| Force Transfer     | Controller function                   | App call + inner transaction transferring ARC-200 units using controller authority        |
| Document Hashes    | On-chain mapping                      | App global state / boxes storing (name -> struct {hash, URI, timestamp})                  |
| Compliance Data    | Contract storage                      | Local state (per address flags) + boxes for extended KYC metadata                         |

## 6. Transaction Patterns

Implementations SHOULD leverage atomic groups:

1. Validate transfer: App call (method: `validate_transfer(partition, from, to, amount, data)` ) returning success code via log or state write.
2. Execute ARC-200 transfer: Subsequent token transfer (or inner transaction) referencing validated parameters. App SHOULD enforce replay protection by tagging group ID / round.

Forced operations (ARC-1644) MUST be executed as: governance-signed App call + inner ARC-200 transfer using controller-managed authority.

## 7. Standard Keys and ABI

Recommended ABI method names (snake_case) with ARC-4 type signatures (arguments then return types where applicable). Unless specified otherwise `uint64` refers to ARC-4 `uint64`, `byte[]` to ARC-4 `bytes`, and addresses to ARC-4 `address`.

- `issue(to: address, amount: uint64, partition: bytes32, data: bytes)`
- `redeem(from: address, amount: uint64, partition: bytes32, data: bytes)`
- `validate_transfer(partition: bytes32, from: address, to: address, amount: uint64, data: bytes) -> (code: uint64, reason: bytes)`
- `transfer_by_partition(from: address, to: address, partition: bytes32, amount: uint64, data: bytes) -> (code: uint64, reason: bytes)`
- `set_document(name: bytes, uri: bytes, hash: bytes32)`
- `get_document(name: bytes) -> (uri: bytes, hash: bytes32, timestamp: uint64)`
- `controller_transfer(from: address, to: address, partition: bytes32, amount: uint64, data: bytes, operator_data: bytes) -> (code: uint64)`
- `controller_redeem(from: address, partition: bytes32, amount: uint64, operator_data: bytes) -> (code: uint64)`
- `set_investor_flag(addr: address, flag_key: bytes, value: uint64)`

Notes:

- `bytes32` indicates fixed-length 32-byte value (ARC-4 fixed-bytes type). Where partition keys are variable length labels, they MUST be hashed to 32 bytes for these interfaces.
- Implementations MAY expose supplementary view methods for pagination; those should follow the same snake_case + ARC-4 typing convention.

Box / state key naming MUST be canonical ASCII lowercase with hyphen separation where applicable.

## 8. Return Codes

ARC-1594 defines standardized failure codes; see that spec. Implementations MUST log the code (uint64) in the validate call and MAY log a reason (UTF-8 string) for discovery off-chain.

## 9. Security Considerations

- Use logic to prevent double-spend across partitions (sum of partitions == ARC-200 balance).
- Ensure controller authority cannot bypass validation except where explicitly permitted.
- Off-chain document URIs must be integrity-protected by cryptographic hash; consider IPFS CID v1.
- Governance multisig threshold changes must be timelocked.
- Avoid storing PII on-chain; store only hashed or coded references.

## 10. Backwards Compatibility

ARC-1400 implementers MAY simultaneously expose standard ARC-200 metadata fields. Non-partitioned wallets can still transfer unrestricted partition units if exposed as standard ARC-200 units where appropriate.

## 11. Reference Implementation

A reference TEAL / TypeScript implementation will accompany this specification in the repository (`smart_contracts/security_token`).

## 12. Copyright

Copyright and related rights waived via CC0 1.0 Universal.
