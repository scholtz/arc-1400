#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 32 8
    bytecblock "arc88_o" 0x151f7c75 0x0000000000000000000000000000000000000000000000000000000000000000 "arc88_po" "arc88_oi" "b" "t" 0x80 0x00 0x7983c35c 0x4355d2ad
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txn NumAppArgs
    bz main_bare_routing@25
    pushbytess 0x975382e2 0x657d13ec 0xb6ae1a25 0x84ec13d5 0xec996041 0x82e573c4 0xda7025b9 0x4a968f8f 0xb5422125 0xbbb319f3 0x0702654e 0xd015724e 0x029fecc0 0x7349334e 0xdb7c82ef 0xfd2c2c6e 0x42a5f065 0xad4f68ea // method "bootstrap(byte[],byte[],uint8,uint256)bool", method "arc200_name()byte[32]", method "arc200_symbol()byte[8]", method "arc200_decimals()uint8", method "arc200_totalSupply()uint256", method "arc200_balanceOf(address)uint256", method "arc200_transfer(address,uint256)bool", method "arc200_transferFrom(address,address,uint256)bool", method "arc200_approve(address,uint256)bool", method "arc200_allowance(address,address)uint256", method "arc88_owner()address", method "arc88_is_owner(address)bool", method "arc88_initialize_owner(address)void", method "arc88_transfer_ownership(address)void", method "arc88_renounce_ownership()void", method "arc88_transfer_ownership_request(address)void", method "arc88_accept_ownership()void", method "arc88_cancel_ownership_request()void"
    txna ApplicationArgs 0
    match main_bootstrap_route@5 main_arc200_name_route@6 main_arc200_symbol_route@7 main_arc200_decimals_route@8 main_arc200_totalSupply_route@9 main_arc200_balanceOf_route@10 main_arc200_transfer_route@11 main_arc200_transferFrom_route@12 main_arc200_approve_route@13 main_arc200_allowance_route@14 main_arc88_owner_route@15 main_arc88_is_owner_route@16 main_arc88_initialize_owner_route@17 main_arc88_transfer_ownership_route@18 main_arc88_renounce_ownership_route@19 main_arc88_transfer_ownership_request_route@20 main_arc88_accept_ownership_route@21 main_arc88_cancel_ownership_request_route@22

main_after_if_else@29:
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    intc_0 // 0
    return

main_arc88_cancel_ownership_request_route@22:
    // smart_contracts/security_token/arc88.algo.ts:103
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc88_cancel_ownership_request
    intc_1 // 1
    return

main_arc88_accept_ownership_route@21:
    // smart_contracts/security_token/arc88.algo.ts:90
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc88_accept_ownership
    intc_1 // 1
    return

main_arc88_transfer_ownership_request_route@20:
    // smart_contracts/security_token/arc88.algo.ts:78
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txna ApplicationArgs 1
    // smart_contracts/security_token/arc88.algo.ts:78
    // @arc4.abimethod()
    callsub arc88_transfer_ownership_request
    intc_1 // 1
    return

main_arc88_renounce_ownership_route@19:
    // smart_contracts/security_token/arc88.algo.ts:68
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc88_renounce_ownership
    intc_1 // 1
    return

main_arc88_transfer_ownership_route@18:
    // smart_contracts/security_token/arc88.algo.ts:58
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txna ApplicationArgs 1
    // smart_contracts/security_token/arc88.algo.ts:58
    // @arc4.abimethod()
    callsub arc88_transfer_ownership
    intc_1 // 1
    return

main_arc88_initialize_owner_route@17:
    // smart_contracts/security_token/arc88.algo.ts:50
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txna ApplicationArgs 1
    // smart_contracts/security_token/arc88.algo.ts:50
    // @arc4.abimethod()
    callsub arc88_initialize_owner
    intc_1 // 1
    return

main_arc88_is_owner_route@16:
    // smart_contracts/security_token/arc88.algo.ts:41
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txna ApplicationArgs 1
    // smart_contracts/security_token/arc88.algo.ts:41
    // @arc4.abimethod({ readonly: true })
    callsub arc88_is_owner
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc88_owner_route@15:
    // smart_contracts/security_token/arc88.algo.ts:35
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc88_owner
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc200_allowance_route@14:
    // smart_contracts/security_token/arc200.algo.ts:177
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/security_token/arc200.algo.ts:177
    // @arc4.abimethod({ readonly: true })
    callsub arc200_allowance
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc200_approve_route@13:
    // smart_contracts/security_token/arc200.algo.ts:165
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/security_token/arc200.algo.ts:165
    // @arc4.abimethod()
    callsub arc200_approve
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc200_transferFrom_route@12:
    // smart_contracts/security_token/arc200.algo.ts:148
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/security_token/arc200.algo.ts:148
    // @arc4.abimethod()
    callsub arc200_transferFrom
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc200_transfer_route@11:
    // smart_contracts/security_token/arc200.algo.ts:135
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/security_token/arc200.algo.ts:135
    // @arc4.abimethod()
    callsub arc200_transfer
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc200_balanceOf_route@10:
    // smart_contracts/security_token/arc200.algo.ts:123
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txna ApplicationArgs 1
    // smart_contracts/security_token/arc200.algo.ts:123
    // @arc4.abimethod({ readonly: true })
    callsub arc200_balanceOf
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc200_totalSupply_route@9:
    // smart_contracts/security_token/arc200.algo.ts:112
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_totalSupply
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc200_decimals_route@8:
    // smart_contracts/security_token/arc200.algo.ts:102
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_decimals
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc200_symbol_route@7:
    // smart_contracts/security_token/arc200.algo.ts:92
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_symbol
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc200_name_route@6:
    // smart_contracts/security_token/arc200.algo.ts:82
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_name
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bootstrap_route@5:
    // smart_contracts/security_token/arc200.algo.ts:56
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/security_token/arc200.algo.ts:56
    // @arc4.abimethod()
    callsub bootstrap
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@25:
    // smart_contracts/security_token/arc200.algo.ts:35
    // export class Arc200 extends Arc88 {
    txn OnCompletion
    bnz main_after_if_else@29
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/security_token/arc200.algo.ts::Arc200.bootstrap(name: bytes, symbol: bytes, decimals: bytes, totalSupply: bytes) -> bytes:
bootstrap:
    // smart_contracts/security_token/arc200.algo.ts:56-57
    // @arc4.abimethod()
    // public bootstrap(name: DynamicBytes, symbol: DynamicBytes, decimals: UintN8, totalSupply: UintN256): Bool {
    proto 4 1
    // smart_contracts/security_token/arc200.algo.ts:58
    // assert(Txn.sender === Global.creatorAddress, 'Only deployer of this smart contract can call bootstrap method')
    txn Sender
    global CreatorAddress
    ==
    assert // Only deployer of this smart contract can call bootstrap method
    // smart_contracts/security_token/arc200.algo.ts:59
    // assert(name.native.length > 0, 'Name of the asset must be longer or equal to 1 character')
    frame_dig -4
    extract 2 0
    len
    dup
    assert // Name of the asset must be longer or equal to 1 character
    // smart_contracts/security_token/arc200.algo.ts:60
    // assert(name.native.length <= 32, 'Name of the asset must be shorter or equal to 32 characters')
    intc_2 // 32
    <=
    assert // Name of the asset must be shorter or equal to 32 characters
    // smart_contracts/security_token/arc200.algo.ts:61
    // assert(symbol.native.length > 0, 'Symbol of the asset must be longer or equal to 1 character')
    frame_dig -3
    extract 2 0
    len
    dup
    assert // Symbol of the asset must be longer or equal to 1 character
    // smart_contracts/security_token/arc200.algo.ts:62
    // assert(symbol.native.length <= 8, 'Symbol of the asset must be shorter or equal to 8 characters')
    intc_3 // 8
    <=
    assert // Symbol of the asset must be shorter or equal to 8 characters
    // smart_contracts/security_token/arc200.algo.ts:51
    // public totalSupply = GlobalState<UintN256>({ key: 't' })
    intc_0 // 0
    bytec 6 // "t"
    // smart_contracts/security_token/arc200.algo.ts:63
    // assert(!this.totalSupply.hasValue, 'This method can be called only once')
    app_global_get_ex
    bury 1
    !
    assert // This method can be called only once
    // smart_contracts/security_token/arc200.algo.ts:39
    // public name = GlobalState<DynamicBytes>({ key: 'n' })
    pushbytes "n"
    // smart_contracts/security_token/arc200.algo.ts:65
    // this.name.value = name
    frame_dig -4
    app_global_put
    // smart_contracts/security_token/arc200.algo.ts:43
    // public symbol = GlobalState<DynamicBytes>({ key: 's' })
    pushbytes "s"
    // smart_contracts/security_token/arc200.algo.ts:66
    // this.symbol.value = symbol
    frame_dig -3
    app_global_put
    // smart_contracts/security_token/arc200.algo.ts:51
    // public totalSupply = GlobalState<UintN256>({ key: 't' })
    bytec 6 // "t"
    // smart_contracts/security_token/arc200.algo.ts:67
    // this.totalSupply.value = totalSupply
    frame_dig -1
    app_global_put
    // smart_contracts/security_token/arc200.algo.ts:47
    // public decimals = GlobalState<UintN8>({ key: 'd' })
    pushbytes "d"
    // smart_contracts/security_token/arc200.algo.ts:68
    // this.decimals.value = decimals
    frame_dig -2
    app_global_put
    // smart_contracts/security_token/arc200.algo.ts:69
    // const sender = new Address(Txn.sender)
    txn Sender
    // smart_contracts/security_token/arc200.algo.ts:53
    // public balances = BoxMap<Address, UintN256>({ keyPrefix: 'b' })
    bytec 5 // "b"
    dig 1
    concat
    // smart_contracts/security_token/arc200.algo.ts:71
    // this.balances(sender).value = totalSupply
    frame_dig -1
    box_put
    // smart_contracts/security_token/arc200.algo.ts:73
    // emit(new arc200_Transfer({ from: new Address(Global.zeroAddress), to: sender, value: totalSupply }))
    global ZeroAddress
    swap
    concat
    frame_dig -1
    concat
    bytec 9 // method "arc200_Transfer(address,address,uint256)"
    swap
    concat
    log
    // smart_contracts/security_token/arc200.algo.ts:74
    // return new Bool(true)
    bytec 7 // 0x80
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_name() -> bytes:
arc200_name:
    // smart_contracts/security_token/arc200.algo.ts:39
    // public name = GlobalState<DynamicBytes>({ key: 'n' })
    intc_0 // 0
    pushbytes "n"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc200.algo.ts:84
    // return new StaticBytes<32>(this.name.value.native)
    extract 2 0
    dup
    len
    intc_2 // 32
    ==
    assert // invalid size
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_symbol() -> bytes:
arc200_symbol:
    // smart_contracts/security_token/arc200.algo.ts:43
    // public symbol = GlobalState<DynamicBytes>({ key: 's' })
    intc_0 // 0
    pushbytes "s"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc200.algo.ts:94
    // return new StaticBytes<8>(this.symbol.value.native)
    extract 2 0
    dup
    len
    intc_3 // 8
    ==
    assert // invalid size
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_decimals() -> bytes:
arc200_decimals:
    // smart_contracts/security_token/arc200.algo.ts:47
    // public decimals = GlobalState<UintN8>({ key: 'd' })
    intc_0 // 0
    pushbytes "d"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc200.algo.ts:104
    // return this.decimals.value
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_totalSupply() -> bytes:
arc200_totalSupply:
    // smart_contracts/security_token/arc200.algo.ts:51
    // public totalSupply = GlobalState<UintN256>({ key: 't' })
    intc_0 // 0
    bytec 6 // "t"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc200.algo.ts:114
    // return this.totalSupply.value
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_balanceOf(owner: bytes) -> bytes:
arc200_balanceOf:
    // smart_contracts/security_token/arc200.algo.ts:123-124
    // @arc4.abimethod({ readonly: true })
    // public arc200_balanceOf(owner: Address): arc4.UintN256 {
    proto 1 1
    // smart_contracts/security_token/arc200.algo.ts:125
    // return this._balanceOf(owner)
    frame_dig -1
    callsub _balanceOf
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_transfer(to: bytes, value: bytes) -> bytes:
arc200_transfer:
    // smart_contracts/security_token/arc200.algo.ts:135-136
    // @arc4.abimethod()
    // public arc200_transfer(to: Address, value: arc4.UintN256): arc4.Bool {
    proto 2 1
    // smart_contracts/security_token/arc200.algo.ts:137
    // return this._transfer(new Address(Txn.sender), to, value)
    txn Sender
    frame_dig -2
    frame_dig -1
    callsub _transfer
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_transferFrom(from: bytes, to: bytes, value: bytes) -> bytes:
arc200_transferFrom:
    // smart_contracts/security_token/arc200.algo.ts:148-149
    // @arc4.abimethod()
    // public arc200_transferFrom(from: Address, to: Address, value: arc4.UintN256): arc4.Bool {
    proto 3 1
    // smart_contracts/security_token/arc200.algo.ts:150
    // const spender = new Address(Txn.sender)
    txn Sender
    // smart_contracts/security_token/arc200.algo.ts:151
    // const spender_allowance = this._allowance(from, spender)
    frame_dig -3
    dig 1
    callsub _allowance
    // smart_contracts/security_token/arc200.algo.ts:152
    // assert(spender_allowance.native >= value.native, 'insufficient approval')
    dup
    frame_dig -1
    b>=
    assert // insufficient approval
    // smart_contracts/security_token/arc200.algo.ts:153
    // const new_spender_allowance = new UintN256(spender_allowance.native - value.native)
    frame_dig -1
    b-
    dup
    len
    intc_2 // 32
    <=
    assert // overflow
    intc_2 // 32
    bzero
    b|
    // smart_contracts/security_token/arc200.algo.ts:154
    // this._approve(from, spender, new_spender_allowance)
    frame_dig -3
    cover 2
    callsub _approve
    pop
    // smart_contracts/security_token/arc200.algo.ts:155
    // return this._transfer(from, to, value)
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub _transfer
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_approve(spender: bytes, value: bytes) -> bytes:
arc200_approve:
    // smart_contracts/security_token/arc200.algo.ts:165-166
    // @arc4.abimethod()
    // public arc200_approve(spender: Address, value: arc4.UintN256): Bool {
    proto 2 1
    // smart_contracts/security_token/arc200.algo.ts:167
    // const owner = new Address(Txn.sender)
    txn Sender
    // smart_contracts/security_token/arc200.algo.ts:168
    // return this._approve(owner, spender, value)
    frame_dig -2
    frame_dig -1
    callsub _approve
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_allowance(owner: bytes, spender: bytes) -> bytes:
arc200_allowance:
    // smart_contracts/security_token/arc200.algo.ts:177-178
    // @arc4.abimethod({ readonly: true })
    // public arc200_allowance(owner: Address, spender: Address): arc4.UintN256 {
    proto 2 1
    // smart_contracts/security_token/arc200.algo.ts:179
    // return this._allowance(owner, spender)
    frame_dig -2
    frame_dig -1
    callsub _allowance
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200._balanceOf(owner: bytes) -> bytes:
_balanceOf:
    // smart_contracts/security_token/arc200.algo.ts:182
    // protected _balanceOf(owner: Address): UintN256 {
    proto 1 1
    // smart_contracts/security_token/arc200.algo.ts:53
    // public balances = BoxMap<Address, UintN256>({ keyPrefix: 'b' })
    bytec 5 // "b"
    frame_dig -1
    concat
    dup
    // smart_contracts/security_token/arc200.algo.ts:183
    // if (!this.balances(owner).exists) return new UintN256(0)
    box_len
    bury 1
    bnz _balanceOf_after_if_else@2
    bytec_2 // 0x0000000000000000000000000000000000000000000000000000000000000000
    swap
    retsub

_balanceOf_after_if_else@2:
    // smart_contracts/security_token/arc200.algo.ts:184
    // return this.balances(owner).value
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200._transfer(sender: bytes, recipient: bytes, amount: bytes) -> bytes:
_transfer:
    // smart_contracts/security_token/arc200.algo.ts:187
    // protected _transfer(sender: Address, recipient: Address, amount: UintN256): Bool {
    proto 3 1
    // smart_contracts/security_token/arc200.algo.ts:188
    // const sender_balance = this._balanceOf(sender)
    frame_dig -3
    callsub _balanceOf
    dup
    // smart_contracts/security_token/arc200.algo.ts:189
    // const recipient_balance = this._balanceOf(recipient)
    frame_dig -2
    callsub _balanceOf
    swap
    // smart_contracts/security_token/arc200.algo.ts:190
    // assert(sender_balance.native >= amount.native, 'Insufficient balance at the sender account')
    frame_dig -1
    b>=
    assert // Insufficient balance at the sender account
    // smart_contracts/security_token/arc200.algo.ts:192
    // if (sender !== recipient) {
    frame_dig -3
    frame_dig -2
    !=
    bz _transfer_after_if_else@2
    // smart_contracts/security_token/arc200.algo.ts:194
    // this.balances(sender).value = new UintN256(sender_balance.native - amount.native)
    frame_dig 0
    frame_dig -1
    b-
    dup
    len
    intc_2 // 32
    <=
    assert // overflow
    intc_2 // 32
    bzero
    swap
    dig 1
    b|
    // smart_contracts/security_token/arc200.algo.ts:53
    // public balances = BoxMap<Address, UintN256>({ keyPrefix: 'b' })
    bytec 5 // "b"
    frame_dig -3
    concat
    // smart_contracts/security_token/arc200.algo.ts:194
    // this.balances(sender).value = new UintN256(sender_balance.native - amount.native)
    swap
    box_put
    // smart_contracts/security_token/arc200.algo.ts:195
    // this.balances(recipient).value = new UintN256(recipient_balance.native + amount.native)
    frame_dig 1
    frame_dig -1
    b+
    dup
    len
    intc_2 // 32
    <=
    assert // overflow
    b|
    // smart_contracts/security_token/arc200.algo.ts:53
    // public balances = BoxMap<Address, UintN256>({ keyPrefix: 'b' })
    bytec 5 // "b"
    frame_dig -2
    concat
    // smart_contracts/security_token/arc200.algo.ts:195
    // this.balances(recipient).value = new UintN256(recipient_balance.native + amount.native)
    swap
    box_put

_transfer_after_if_else@2:
    // smart_contracts/security_token/arc200.algo.ts:197
    // emit(new arc200_Transfer({ from: sender, to: recipient, value: amount }))
    frame_dig -3
    frame_dig -2
    concat
    frame_dig -1
    concat
    bytec 9 // method "arc200_Transfer(address,address,uint256)"
    swap
    concat
    log
    // smart_contracts/security_token/arc200.algo.ts:198
    // return new Bool(true)
    bytec 7 // 0x80
    frame_bury 0
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200._approvalKey(owner: bytes, spender: bytes) -> bytes:
_approvalKey:
    // smart_contracts/security_token/arc200.algo.ts:200
    // protected _approvalKey(owner: Address, spender: Address): StaticBytes<32> {
    proto 2 1
    // smart_contracts/security_token/arc200.algo.ts:201
    // return new StaticBytes<32>(op.sha256(op.concat(owner.bytes, spender.bytes)))
    frame_dig -2
    frame_dig -1
    concat
    sha256
    dup
    len
    intc_2 // 32
    ==
    assert // invalid size
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200._allowance(owner: bytes, spender: bytes) -> bytes:
_allowance:
    // smart_contracts/security_token/arc200.algo.ts:204
    // protected _allowance(owner: Address, spender: Address): UintN256 {
    proto 2 1
    // smart_contracts/security_token/arc200.algo.ts:205
    // const key = this._approvalKey(owner, spender)
    frame_dig -2
    frame_dig -1
    callsub _approvalKey
    // smart_contracts/security_token/arc200.algo.ts:55
    // public approvals = BoxMap<StaticBytes<32>, ApprovalStruct>({ keyPrefix: 'a' })
    pushbytes "a"
    swap
    concat
    dup
    // smart_contracts/security_token/arc200.algo.ts:206
    // if (!this.approvals(key).exists) return new UintN256(0)
    box_len
    bury 1
    bnz _allowance_after_if_else@2
    bytec_2 // 0x0000000000000000000000000000000000000000000000000000000000000000
    swap
    retsub

_allowance_after_if_else@2:
    // smart_contracts/security_token/arc200.algo.ts:207
    // return this.approvals(key).value.approvalAmount
    frame_dig 0
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    swap
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200._approve(owner: bytes, spender: bytes, amount: bytes) -> bytes:
_approve:
    // smart_contracts/security_token/arc200.algo.ts:210
    // protected _approve(owner: Address, spender: Address, amount: UintN256): Bool {
    proto 3 1
    // smart_contracts/security_token/arc200.algo.ts:211
    // const key = this._approvalKey(owner, spender)
    frame_dig -3
    frame_dig -2
    callsub _approvalKey
    // smart_contracts/security_token/arc200.algo.ts:212-216
    // const approvalBox: ApprovalStruct = new ApprovalStruct({
    //   approvalAmount: amount,
    //   owner: owner,
    //   spender: spender,
    // })
    frame_dig -1
    frame_dig -3
    concat
    frame_dig -2
    concat
    // smart_contracts/security_token/arc200.algo.ts:55
    // public approvals = BoxMap<StaticBytes<32>, ApprovalStruct>({ keyPrefix: 'a' })
    pushbytes "a"
    uncover 2
    concat
    // smart_contracts/security_token/arc200.algo.ts:217
    // this.approvals(key).value = approvalBox.copy()
    swap
    box_put
    // smart_contracts/security_token/arc200.algo.ts:218
    // emit(new arc200_Approval({ owner: owner, spender: spender, value: amount }))
    frame_dig -3
    frame_dig -2
    concat
    frame_dig -1
    concat
    pushbytes 0x1969f865 // method "arc200_Approval(address,address,uint256)"
    swap
    concat
    log
    // smart_contracts/security_token/arc200.algo.ts:219
    // return new Bool(true)
    bytec 7 // 0x80
    retsub


// smart_contracts/security_token/arc88.algo.ts::Arc88._ensureDefaultOwner() -> void:
_ensureDefaultOwner:
    // smart_contracts/security_token/arc88.algo.ts:19
    // public initialized = GlobalState<arc4.Byte>({ key: 'arc88_oi' }) // 1 if initialized (explicit or implicit)
    intc_0 // 0
    bytec 4 // "arc88_oi"
    // smart_contracts/security_token/arc88.algo.ts:27
    // if (!this.initialized.hasValue || this.initialized.value.native === 0) {
    app_global_get_ex
    bury 1
    bz _ensureDefaultOwner_if_body@2
    // smart_contracts/security_token/arc88.algo.ts:19
    // public initialized = GlobalState<arc4.Byte>({ key: 'arc88_oi' }) // 1 if initialized (explicit or implicit)
    intc_0 // 0
    bytec 4 // "arc88_oi"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:27
    // if (!this.initialized.hasValue || this.initialized.value.native === 0) {
    btoi
    bnz _ensureDefaultOwner_after_if_else@5

_ensureDefaultOwner_if_body@2:
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    // smart_contracts/security_token/arc88.algo.ts:28
    // if (!this.owner.hasValue) {
    app_global_get_ex
    bury 1
    bnz _ensureDefaultOwner_after_if_else@4
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    bytec_0 // "arc88_o"
    // smart_contracts/security_token/arc88.algo.ts:29
    // this.owner.value = new arc4.Address(Global.creatorAddress)
    global CreatorAddress
    app_global_put

_ensureDefaultOwner_after_if_else@4:
    // smart_contracts/security_token/arc88.algo.ts:19
    // public initialized = GlobalState<arc4.Byte>({ key: 'arc88_oi' }) // 1 if initialized (explicit or implicit)
    bytec 4 // "arc88_oi"
    // smart_contracts/security_token/arc88.algo.ts:31
    // this.initialized.value = new arc4.Byte(1)
    pushbytes 0x01
    app_global_put

_ensureDefaultOwner_after_if_else@5:
    retsub


// smart_contracts/security_token/arc88.algo.ts::Arc88.arc88_owner() -> bytes:
arc88_owner:
    // smart_contracts/security_token/arc88.algo.ts:37
    // this._ensureDefaultOwner()
    callsub _ensureDefaultOwner
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:38
    // return this.owner.value
    retsub


// smart_contracts/security_token/arc88.algo.ts::Arc88.arc88_is_owner(query: bytes) -> bytes:
arc88_is_owner:
    // smart_contracts/security_token/arc88.algo.ts:41-42
    // @arc4.abimethod({ readonly: true })
    // public arc88_is_owner(query: arc4.Address): arc4.Bool {
    proto 1 1
    // smart_contracts/security_token/arc88.algo.ts:43
    // this._ensureDefaultOwner()
    callsub _ensureDefaultOwner
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    // smart_contracts/security_token/arc88.algo.ts:44
    // if (!this.owner.hasValue) return new arc4.Bool(false)
    app_global_get_ex
    bury 1
    bnz arc88_is_owner_after_if_else@2
    bytec 8 // 0x00
    retsub

arc88_is_owner_after_if_else@2:
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:45
    // if (this.owner.value === new arc4.Address()) return new arc4.Bool(false)
    bytec_2 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    ==
    bz arc88_is_owner_after_if_else@4
    bytec 8 // 0x00
    retsub

arc88_is_owner_after_if_else@4:
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:46
    // return new arc4.Bool(this.owner.value === query)
    frame_dig -1
    ==
    bytec 8 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    retsub


// smart_contracts/security_token/arc88.algo.ts::Arc88.arc88_initialize_owner(new_owner: bytes) -> void:
arc88_initialize_owner:
    // smart_contracts/security_token/arc88.algo.ts:50-51
    // @arc4.abimethod()
    // public arc88_initialize_owner(new_owner: arc4.Address): void {
    proto 1 0
    // smart_contracts/security_token/arc88.algo.ts:19
    // public initialized = GlobalState<arc4.Byte>({ key: 'arc88_oi' }) // 1 if initialized (explicit or implicit)
    intc_0 // 0
    bytec 4 // "arc88_oi"
    // smart_contracts/security_token/arc88.algo.ts:52
    // assert(!(this.initialized.hasValue && this.initialized.value.native === 1), 'already_initialized')
    app_global_get_ex
    bury 1
    bz arc88_initialize_owner_bool_false@3
    // smart_contracts/security_token/arc88.algo.ts:19
    // public initialized = GlobalState<arc4.Byte>({ key: 'arc88_oi' }) // 1 if initialized (explicit or implicit)
    intc_0 // 0
    bytec 4 // "arc88_oi"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:52
    // assert(!(this.initialized.hasValue && this.initialized.value.native === 1), 'already_initialized')
    btoi
    intc_1 // 1
    ==
    bz arc88_initialize_owner_bool_false@3
    intc_1 // 1

arc88_initialize_owner_bool_merge@4:
    // smart_contracts/security_token/arc88.algo.ts:52
    // assert(!(this.initialized.hasValue && this.initialized.value.native === 1), 'already_initialized')
    !
    assert // already_initialized
    // smart_contracts/security_token/arc88.algo.ts:53
    // assert(new_owner !== new arc4.Address(), 'zero_address_not_allowed')
    frame_dig -1
    bytec_2 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    !=
    assert // zero_address_not_allowed
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    bytec_0 // "arc88_o"
    // smart_contracts/security_token/arc88.algo.ts:54
    // this.owner.value = new_owner
    frame_dig -1
    app_global_put
    // smart_contracts/security_token/arc88.algo.ts:19
    // public initialized = GlobalState<arc4.Byte>({ key: 'arc88_oi' }) // 1 if initialized (explicit or implicit)
    bytec 4 // "arc88_oi"
    // smart_contracts/security_token/arc88.algo.ts:55
    // this.initialized.value = new arc4.Byte(1)
    pushbytes 0x01
    app_global_put
    retsub

arc88_initialize_owner_bool_false@3:
    intc_0 // 0
    b arc88_initialize_owner_bool_merge@4


// smart_contracts/security_token/arc88.algo.ts::Arc88.arc88_transfer_ownership(new_owner: bytes) -> void:
arc88_transfer_ownership:
    // smart_contracts/security_token/arc88.algo.ts:58-59
    // @arc4.abimethod()
    // public arc88_transfer_ownership(new_owner: arc4.Address): void {
    proto 1 0
    // smart_contracts/security_token/arc88.algo.ts:60
    // this._ensureDefaultOwner()
    callsub _ensureDefaultOwner
    // smart_contracts/security_token/arc88.algo.ts:61
    // assert(new arc4.Address(Txn.sender) === this.owner.value, 'not_owner')
    txn Sender
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:61
    // assert(new arc4.Address(Txn.sender) === this.owner.value, 'not_owner')
    ==
    assert // not_owner
    // smart_contracts/security_token/arc88.algo.ts:62
    // assert(new_owner !== new arc4.Address(), 'zero_address_not_allowed')
    frame_dig -1
    bytec_2 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    !=
    assert // zero_address_not_allowed
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    app_global_get_ex
    assert // check GlobalState exists
    bytec_0 // "arc88_o"
    // smart_contracts/security_token/arc88.algo.ts:64
    // this.owner.value = new_owner
    frame_dig -1
    app_global_put
    // smart_contracts/security_token/arc88.algo.ts:65
    // emit(new arc88_OwnershipTransferred({ previous_owner: previous, new_owner }))
    frame_dig -1
    concat
    bytec 10 // method "arc88_OwnershipTransferred(address,address)"
    swap
    concat
    log
    retsub


// smart_contracts/security_token/arc88.algo.ts::Arc88.arc88_renounce_ownership() -> void:
arc88_renounce_ownership:
    // smart_contracts/security_token/arc88.algo.ts:70
    // this._ensureDefaultOwner()
    callsub _ensureDefaultOwner
    // smart_contracts/security_token/arc88.algo.ts:71
    // assert(new arc4.Address(Txn.sender) === this.owner.value, 'not_owner')
    txn Sender
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:71
    // assert(new arc4.Address(Txn.sender) === this.owner.value, 'not_owner')
    ==
    assert // not_owner
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    app_global_get_ex
    assert // check GlobalState exists
    bytec_0 // "arc88_o"
    // smart_contracts/security_token/arc88.algo.ts:73
    // this.owner.value = new arc4.Address()
    bytec_2 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    app_global_put
    // smart_contracts/security_token/arc88.algo.ts:74
    // emit(new arc88_OwnershipRenounced({ previous_owner: previous }))
    pushbytes 0x346aa166 // method "arc88_OwnershipRenounced(address)"
    swap
    concat
    log
    retsub


// smart_contracts/security_token/arc88.algo.ts::Arc88.arc88_transfer_ownership_request(pending: bytes) -> void:
arc88_transfer_ownership_request:
    // smart_contracts/security_token/arc88.algo.ts:78-79
    // @arc4.abimethod()
    // public arc88_transfer_ownership_request(pending: arc4.Address): void {
    proto 1 0
    // smart_contracts/security_token/arc88.algo.ts:80
    // this._ensureDefaultOwner()
    callsub _ensureDefaultOwner
    // smart_contracts/security_token/arc88.algo.ts:81
    // assert(new arc4.Address(Txn.sender) === this.owner.value, 'not_owner')
    txn Sender
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:81
    // assert(new arc4.Address(Txn.sender) === this.owner.value, 'not_owner')
    ==
    assert // not_owner
    // smart_contracts/security_token/arc88.algo.ts:82
    // assert(pending !== new arc4.Address(), 'zero_address_not_allowed')
    frame_dig -1
    bytec_2 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    !=
    assert // zero_address_not_allowed
    // smart_contracts/security_token/arc88.algo.ts:18
    // public pendingOwner = GlobalState<arc4.Address>({ key: 'arc88_po' }) // optional two-step
    intc_0 // 0
    bytec_3 // "arc88_po"
    // smart_contracts/security_token/arc88.algo.ts:83
    // if (this.pendingOwner.hasValue && this.pendingOwner.value !== new arc4.Address()) {
    app_global_get_ex
    bury 1
    bz arc88_transfer_ownership_request_after_if_else@3
    // smart_contracts/security_token/arc88.algo.ts:18
    // public pendingOwner = GlobalState<arc4.Address>({ key: 'arc88_po' }) // optional two-step
    intc_0 // 0
    bytec_3 // "arc88_po"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:83
    // if (this.pendingOwner.hasValue && this.pendingOwner.value !== new arc4.Address()) {
    bytec_2 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    !=
    !
    assert // pending_transfer_exists

arc88_transfer_ownership_request_after_if_else@3:
    // smart_contracts/security_token/arc88.algo.ts:18
    // public pendingOwner = GlobalState<arc4.Address>({ key: 'arc88_po' }) // optional two-step
    bytec_3 // "arc88_po"
    // smart_contracts/security_token/arc88.algo.ts:86
    // this.pendingOwner.value = pending
    frame_dig -1
    app_global_put
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:87
    // emit(new arc88_OwnershipTransferRequested({ previous_owner: this.owner.value, pending_owner: pending }))
    frame_dig -1
    concat
    pushbytes 0x16bf1f91 // method "arc88_OwnershipTransferRequested(address,address)"
    swap
    concat
    log
    retsub


// smart_contracts/security_token/arc88.algo.ts::Arc88.arc88_accept_ownership() -> void:
arc88_accept_ownership:
    // smart_contracts/security_token/arc88.algo.ts:92
    // this._ensureDefaultOwner()
    callsub _ensureDefaultOwner
    // smart_contracts/security_token/arc88.algo.ts:18
    // public pendingOwner = GlobalState<arc4.Address>({ key: 'arc88_po' }) // optional two-step
    intc_0 // 0
    bytec_3 // "arc88_po"
    // smart_contracts/security_token/arc88.algo.ts:93
    // assert(this.pendingOwner.hasValue, 'not_pending_owner')
    app_global_get_ex
    bury 1
    assert // not_pending_owner
    // smart_contracts/security_token/arc88.algo.ts:94
    // const sender = new arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/security_token/arc88.algo.ts:18
    // public pendingOwner = GlobalState<arc4.Address>({ key: 'arc88_po' }) // optional two-step
    intc_0 // 0
    bytec_3 // "arc88_po"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:95
    // assert(sender === this.pendingOwner.value, 'not_pending_owner')
    dig 1
    ==
    assert // not_pending_owner
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    app_global_get_ex
    assert // check GlobalState exists
    bytec_0 // "arc88_o"
    // smart_contracts/security_token/arc88.algo.ts:97
    // this.owner.value = sender
    dig 2
    app_global_put
    // smart_contracts/security_token/arc88.algo.ts:18
    // public pendingOwner = GlobalState<arc4.Address>({ key: 'arc88_po' }) // optional two-step
    bytec_3 // "arc88_po"
    // smart_contracts/security_token/arc88.algo.ts:98
    // this.pendingOwner.value = new arc4.Address()
    bytec_2 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    app_global_put
    // smart_contracts/security_token/arc88.algo.ts:99
    // emit(new arc88_OwnershipTransferAccepted({ previous_owner: previous, new_owner: sender }))
    swap
    concat
    pushbytes 0xf7e36b37 // method "arc88_OwnershipTransferAccepted(address,address)"
    dig 1
    concat
    log
    // smart_contracts/security_token/arc88.algo.ts:100
    // emit(new arc88_OwnershipTransferred({ previous_owner: previous, new_owner: sender }))
    bytec 10 // method "arc88_OwnershipTransferred(address,address)"
    swap
    concat
    log
    retsub


// smart_contracts/security_token/arc88.algo.ts::Arc88.arc88_cancel_ownership_request() -> void:
arc88_cancel_ownership_request:
    // smart_contracts/security_token/arc88.algo.ts:105
    // this._ensureDefaultOwner()
    callsub _ensureDefaultOwner
    // smart_contracts/security_token/arc88.algo.ts:106
    // assert(new arc4.Address(Txn.sender) === this.owner.value, 'not_owner')
    txn Sender
    // smart_contracts/security_token/arc88.algo.ts:17
    // public owner = GlobalState<arc4.Address>({ key: 'arc88_o' })
    intc_0 // 0
    bytec_0 // "arc88_o"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc88.algo.ts:106
    // assert(new arc4.Address(Txn.sender) === this.owner.value, 'not_owner')
    ==
    assert // not_owner
    // smart_contracts/security_token/arc88.algo.ts:18
    // public pendingOwner = GlobalState<arc4.Address>({ key: 'arc88_po' }) // optional two-step
    bytec_3 // "arc88_po"
    // smart_contracts/security_token/arc88.algo.ts:107
    // this.pendingOwner.value = new arc4.Address()
    bytec_2 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    app_global_put
    retsub
