#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 32 8
    bytecblock 0x151f7c75 0x0000000000000000000000000000000000000000000000000000000000000000 0x80 "p" "hp_a" "op" "opa" "b" 0x00 0x0001 "t" 0x0000 0x0000000000000000 0x7983c35c
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txn NumAppArgs
    bz main_bare_routing@27
    pushbytess 0x35f8135f 0xda7025b9 0x3f256713 0x95b4f9e3 0x80cc49ab 0x07962165 0xe78961da 0xfd9480d7 0xb1b1d69a 0xc1bed789 0x3bfe1833 0x975382e2 0x657d13ec 0xb6ae1a25 0x84ec13d5 0xec996041 0x82e573c4 0x4a968f8f 0xb5422125 0xbbb319f3 // method "arc1410_balance_of_partition(address,address)uint256", method "arc200_transfer(address,uint256)bool", method "arc1410_transfer_by_partition(address,address,uint256,byte[])address", method "arc1410_partitions_of(address,uint64)address[]", method "arc1410_is_operator(address,address,address)bool", method "arc1410_authorize_operator(address,address,address)void", method "arc1410_revoke_operator(address,address,address)void", method "arc1410_operator_transfer_by_partition(address,address,address,uint256,byte[])address", method "arc1410_can_transfer_by_partition(address,address,address,uint256,byte[])(byte,string,address)", method "arc1410_authorize_operator_by_portion(address,address,address,uint256)void", method "arc1410_is_operator_by_portion(address,address,address)bool", method "bootstrap(byte[],byte[],uint8,uint256)bool", method "arc200_name()byte[32]", method "arc200_symbol()byte[8]", method "arc200_decimals()uint8", method "arc200_totalSupply()uint256", method "arc200_balanceOf(address)uint256", method "arc200_transferFrom(address,address,uint256)bool", method "arc200_approve(address,uint256)bool", method "arc200_allowance(address,address)uint256"
    txna ApplicationArgs 0
    match main_arc1410_balance_of_partition_route@5 main_arc200_transfer_route@6 main_arc1410_transfer_by_partition_route@7 main_arc1410_partitions_of_route@8 main_arc1410_is_operator_route@9 main_arc1410_authorize_operator_route@10 main_arc1410_revoke_operator_route@11 main_arc1410_operator_transfer_by_partition_route@12 main_arc1410_can_transfer_by_partition_route@13 main_arc1410_authorize_operator_by_portion_route@14 main_arc1410_is_operator_by_portion_route@15 main_bootstrap_route@16 main_arc200_name_route@17 main_arc200_symbol_route@18 main_arc200_decimals_route@19 main_arc200_totalSupply_route@20 main_arc200_balanceOf_route@21 main_arc200_transferFrom_route@22 main_arc200_approve_route@23 main_arc200_allowance_route@24

main_after_if_else@31:
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    intc_1 // 0
    return

main_arc200_allowance_route@24:
    // smart_contracts/security_token/arc200.algo.ts:186
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/security_token/arc200.algo.ts:186
    // @arc4.abimethod({ readonly: true })
    callsub arc200_allowance
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_approve_route@23:
    // smart_contracts/security_token/arc200.algo.ts:174
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/security_token/arc200.algo.ts:174
    // @arc4.abimethod()
    callsub arc200_approve
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_transferFrom_route@22:
    // smart_contracts/security_token/arc200.algo.ts:157
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/security_token/arc200.algo.ts:157
    // @arc4.abimethod()
    callsub arc200_transferFrom
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_balanceOf_route@21:
    // smart_contracts/security_token/arc200.algo.ts:132
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    // smart_contracts/security_token/arc200.algo.ts:132
    // @arc4.abimethod({ readonly: true })
    callsub arc200_balanceOf
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_totalSupply_route@20:
    // smart_contracts/security_token/arc200.algo.ts:121
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_totalSupply
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_decimals_route@19:
    // smart_contracts/security_token/arc200.algo.ts:111
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_decimals
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_symbol_route@18:
    // smart_contracts/security_token/arc200.algo.ts:101
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_symbol
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_name_route@17:
    // smart_contracts/security_token/arc200.algo.ts:91
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_name
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bootstrap_route@16:
    // smart_contracts/security_token/arc200.algo.ts:65
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/security_token/arc200.algo.ts:65
    // @arc4.abimethod()
    callsub bootstrap
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc1410_is_operator_by_portion_route@15:
    // smart_contracts/security_token/arc1410.algo.ts:358
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/security_token/arc1410.algo.ts:358
    // @arc4.abimethod({ readonly: true })
    callsub arc1410_is_operator_by_portion
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc1410_authorize_operator_by_portion_route@14:
    // smart_contracts/security_token/arc1410.algo.ts:346
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/security_token/arc1410.algo.ts:346
    // @arc4.abimethod()
    callsub arc1410_authorize_operator_by_portion
    intc_0 // 1
    return

main_arc1410_can_transfer_by_partition_route@13:
    // smart_contracts/security_token/arc1410.algo.ts:161
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    // smart_contracts/security_token/arc1410.algo.ts:161
    // @arc4.abimethod()
    callsub arc1410_can_transfer_by_partition
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc1410_operator_transfer_by_partition_route@12:
    // smart_contracts/security_token/arc1410.algo.ts:131
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    // smart_contracts/security_token/arc1410.algo.ts:131
    // @arc4.abimethod()
    callsub arc1410_operator_transfer_by_partition
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc1410_revoke_operator_route@11:
    // smart_contracts/security_token/arc1410.algo.ts:122
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/security_token/arc1410.algo.ts:122
    // @arc4.abimethod()
    callsub arc1410_revoke_operator
    intc_0 // 1
    return

main_arc1410_authorize_operator_route@10:
    // smart_contracts/security_token/arc1410.algo.ts:115
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/security_token/arc1410.algo.ts:115
    // @arc4.abimethod()
    callsub arc1410_authorize_operator
    intc_0 // 1
    return

main_arc1410_is_operator_route@9:
    // smart_contracts/security_token/arc1410.algo.ts:101
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/security_token/arc1410.algo.ts:101
    // @arc4.abimethod({ readonly: true })
    callsub arc1410_is_operator
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc1410_partitions_of_route@8:
    // smart_contracts/security_token/arc1410.algo.ts:94
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/security_token/arc1410.algo.ts:94
    // @arc4.abimethod()
    callsub arc1410_partitions_of
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc1410_transfer_by_partition_route@7:
    // smart_contracts/security_token/arc1410.algo.ts:80
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/security_token/arc1410.algo.ts:80
    // @arc4.abimethod()
    callsub arc1410_transfer_by_partition
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_transfer_route@6:
    // smart_contracts/security_token/arc1410.algo.ts:65
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/security_token/arc1410.algo.ts:65
    // @arc4.abimethod()
    callsub arc200_transfer
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc1410_balance_of_partition_route@5:
    // smart_contracts/security_token/arc1410.algo.ts:56
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/security_token/arc1410.algo.ts:56
    // @arc4.abimethod({ readonly: true })
    callsub arc1410_balance_of_partition
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@27:
    // smart_contracts/security_token/arc1410.algo.ts:43
    // export class Arc1410 extends Arc200 {
    txn OnCompletion
    bnz main_after_if_else@31
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts/security_token/arc1410.algo.ts::Arc1410.arc1410_balance_of_partition(holder: bytes, partition: bytes) -> bytes:
arc1410_balance_of_partition:
    // smart_contracts/security_token/arc1410.algo.ts:56-57
    // @arc4.abimethod({ readonly: true })
    // public arc1410_balance_of_partition(holder: arc4.Address, partition: arc4.Address): arc4.UintN256 {
    proto 2 1
    // smart_contracts/security_token/arc1410.algo.ts:58-61
    // const key = new arc1410_PartitionKey({
    //   holder: holder,
    //   partition: partition,
    // })
    frame_dig -2
    frame_dig -1
    concat
    // smart_contracts/security_token/arc1410.algo.ts:44
    // public partitions = BoxMap<arc1410_PartitionKey, arc4.UintN256>({ keyPrefix: 'p' })
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/security_token/arc1410.algo.ts:62
    // return this.partitions(key).value
    box_get
    assert // Box must have value
    retsub


// smart_contracts/security_token/arc1410.algo.ts::Arc1410.arc200_transfer(to: bytes, value: bytes) -> bytes:
arc200_transfer:
    // smart_contracts/security_token/arc1410.algo.ts:65-66
    // @arc4.abimethod()
    // public override arc200_transfer(to: arc4.Address, value: arc4.UintN256): arc4.Bool {
    proto 2 1
    // smart_contracts/security_token/arc1410.algo.ts:68
    // new arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/security_token/arc1410.algo.ts:69
    // new arc4.Address(),
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    // smart_contracts/security_token/arc1410.algo.ts:67-74
    // this._transfer_partition(
    //   new arc4.Address(Txn.sender),
    //   new arc4.Address(),
    //   to,
    //   new arc4.Address(),
    //   value,
    //   new arc4.DynamicBytes(),
    // )
    frame_dig -2
    // smart_contracts/security_token/arc1410.algo.ts:71
    // new arc4.Address(),
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    // smart_contracts/security_token/arc1410.algo.ts:67-74
    // this._transfer_partition(
    //   new arc4.Address(Txn.sender),
    //   new arc4.Address(),
    //   to,
    //   new arc4.Address(),
    //   value,
    //   new arc4.DynamicBytes(),
    // )
    frame_dig -1
    // smart_contracts/security_token/arc1410.algo.ts:73
    // new arc4.DynamicBytes(),
    bytec 11 // 0x0000
    // smart_contracts/security_token/arc1410.algo.ts:67-74
    // this._transfer_partition(
    //   new arc4.Address(Txn.sender),
    //   new arc4.Address(),
    //   to,
    //   new arc4.Address(),
    //   value,
    //   new arc4.DynamicBytes(),
    // )
    callsub _transfer_partition
    // smart_contracts/security_token/arc1410.algo.ts:75
    // return this._transfer(new arc4.Address(Txn.sender), to, value)
    txn Sender
    frame_dig -2
    frame_dig -1
    callsub _transfer
    retsub


// smart_contracts/security_token/arc1410.algo.ts::Arc1410.arc1410_transfer_by_partition(partition: bytes, to: bytes, amount: bytes, data: bytes) -> bytes:
arc1410_transfer_by_partition:
    // smart_contracts/security_token/arc1410.algo.ts:80-86
    // @arc4.abimethod()
    // public arc1410_transfer_by_partition(
    //   partition: arc4.Address,
    //   to: arc4.Address,
    //   amount: arc4.UintN256,
    //   data: arc4.DynamicBytes,
    // ): arc4.Address {
    proto 4 1
    // smart_contracts/security_token/arc1410.algo.ts:87
    // const sender = new arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/security_token/arc1410.algo.ts:89
    // let receiverPartition = this._receiverPartition(to, partition)
    frame_dig -3
    frame_dig -4
    callsub _receiverPartition
    // smart_contracts/security_token/arc1410.algo.ts:90
    // this._transfer_partition(sender, partition, to, receiverPartition, amount, data)
    swap
    frame_dig -4
    frame_dig -3
    dig 3
    frame_dig -2
    frame_dig -1
    callsub _transfer_partition
    // smart_contracts/security_token/arc1410.algo.ts:91
    // return receiverPartition
    retsub


// smart_contracts/security_token/arc1410.algo.ts::Arc1410.arc1410_partitions_of(holder: bytes, page: bytes) -> bytes:
arc1410_partitions_of:
    // smart_contracts/security_token/arc1410.algo.ts:94-95
    // @arc4.abimethod()
    // public arc1410_partitions_of(holder: arc4.Address, page: arc4.UintN64): arc4.Address[] {
    proto 2 1
    // smart_contracts/security_token/arc1410.algo.ts:96
    // const key = new arc1410_HoldingPartitionsPaginatedKey({ holder: holder, page: page })
    frame_dig -2
    frame_dig -1
    concat
    // smart_contracts/security_token/arc1410.algo.ts:47
    // keyPrefix: 'hp_a',
    bytec 4 // "hp_a"
    swap
    concat
    dup
    // smart_contracts/security_token/arc1410.algo.ts:97
    // if (!this.holderPartitionsAddresses(key).exists) return []
    box_len
    bury 1
    bnz arc1410_partitions_of_after_if_else@2
    bytec 11 // 0x0000
    swap
    retsub

arc1410_partitions_of_after_if_else@2:
    // smart_contracts/security_token/arc1410.algo.ts:98
    // return this.holderPartitionsAddresses(key).value
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub


// smart_contracts/security_token/arc1410.algo.ts::Arc1410.arc1410_is_operator(holder: bytes, operator: bytes, partition: bytes) -> bytes:
arc1410_is_operator:
    // smart_contracts/security_token/arc1410.algo.ts:101-102
    // @arc4.abimethod({ readonly: true })
    // public arc1410_is_operator(holder: arc4.Address, operator: arc4.Address, partition: arc4.Address): arc4.Bool {
    proto 3 1
    intc_1 // 0
    dupn 2
    // smart_contracts/security_token/arc1410.algo.ts:103
    // if (operator === holder) return new arc4.Bool(true)
    frame_dig -2
    frame_dig -3
    ==
    bz arc1410_is_operator_after_if_else@2
    bytec_2 // 0x80
    frame_bury 0
    retsub

arc1410_is_operator_after_if_else@2:
    // smart_contracts/security_token/arc1410.algo.ts:104
    // const specific = new arc1410_OperatorKey({ holder: holder, operator: operator, partition: partition })
    frame_dig -3
    frame_dig -2
    concat
    dup
    frame_bury 0
    frame_dig -1
    concat
    // smart_contracts/security_token/arc1410.algo.ts:49
    // public operators = BoxMap<arc1410_OperatorKey, arc4.Byte>({ keyPrefix: 'op' }) // value = 1 authorized
    bytec 5 // "op"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/security_token/arc1410.algo.ts:105
    // if (this.operators(specific).exists && this.operators(specific).value.native === 1) {
    box_len
    bury 1
    bz arc1410_is_operator_after_if_else@5
    frame_dig 1
    box_get
    assert // Box must have value
    btoi
    intc_0 // 1
    ==
    bz arc1410_is_operator_after_if_else@5
    // smart_contracts/security_token/arc1410.algo.ts:106
    // return new arc4.Bool(true)
    bytec_2 // 0x80
    frame_bury 0
    retsub

arc1410_is_operator_after_if_else@5:
    // smart_contracts/security_token/arc1410.algo.ts:108
    // const globalKey = new arc1410_OperatorKey({ holder: holder, operator: operator, partition: new arc4.Address() })
    frame_dig 0
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    concat
    // smart_contracts/security_token/arc1410.algo.ts:49
    // public operators = BoxMap<arc1410_OperatorKey, arc4.Byte>({ keyPrefix: 'op' }) // value = 1 authorized
    bytec 5 // "op"
    swap
    concat
    dup
    frame_bury 2
    // smart_contracts/security_token/arc1410.algo.ts:109
    // if (this.operators(globalKey).exists && this.operators(globalKey).value.native === 1) {
    box_len
    bury 1
    bz arc1410_is_operator_after_if_else@8
    frame_dig 2
    box_get
    assert // Box must have value
    btoi
    intc_0 // 1
    ==
    bz arc1410_is_operator_after_if_else@8
    // smart_contracts/security_token/arc1410.algo.ts:110
    // return new arc4.Bool(true)
    bytec_2 // 0x80
    frame_bury 0
    retsub

arc1410_is_operator_after_if_else@8:
    // smart_contracts/security_token/arc1410.algo.ts:112
    // return new arc4.Bool(false)
    bytec 8 // 0x00
    frame_bury 0
    retsub


// smart_contracts/security_token/arc1410.algo.ts::Arc1410.arc1410_authorize_operator(holder: bytes, operator: bytes, partition: bytes) -> void:
arc1410_authorize_operator:
    // smart_contracts/security_token/arc1410.algo.ts:115-116
    // @arc4.abimethod()
    // public arc1410_authorize_operator(holder: arc4.Address, operator: arc4.Address, partition: arc4.Address): void {
    proto 3 0
    // smart_contracts/security_token/arc1410.algo.ts:117
    // assert(new arc4.Address(Txn.sender) === holder, 'Only holder can authorize')
    txn Sender
    frame_dig -3
    ==
    assert // Only holder can authorize
    // smart_contracts/security_token/arc1410.algo.ts:118
    // const key = new arc1410_OperatorKey({ holder: holder, operator: operator, partition: partition })
    frame_dig -3
    frame_dig -2
    concat
    frame_dig -1
    concat
    // smart_contracts/security_token/arc1410.algo.ts:49
    // public operators = BoxMap<arc1410_OperatorKey, arc4.Byte>({ keyPrefix: 'op' }) // value = 1 authorized
    bytec 5 // "op"
    swap
    concat
    // smart_contracts/security_token/arc1410.algo.ts:119
    // this.operators(key).value = new arc4.Byte(1)
    pushbytes 0x01
    box_put
    retsub


// smart_contracts/security_token/arc1410.algo.ts::Arc1410.arc1410_revoke_operator(holder: bytes, operator: bytes, partition: bytes) -> void:
arc1410_revoke_operator:
    // smart_contracts/security_token/arc1410.algo.ts:122-123
    // @arc4.abimethod()
    // public arc1410_revoke_operator(holder: arc4.Address, operator: arc4.Address, partition: arc4.Address): void {
    proto 3 0
    // smart_contracts/security_token/arc1410.algo.ts:124
    // assert(new arc4.Address(Txn.sender) === holder, 'Only holder can revoke')
    txn Sender
    frame_dig -3
    ==
    assert // Only holder can revoke
    // smart_contracts/security_token/arc1410.algo.ts:125
    // const key = new arc1410_OperatorKey({ holder: holder, operator: operator, partition: partition })
    frame_dig -3
    frame_dig -2
    concat
    frame_dig -1
    concat
    // smart_contracts/security_token/arc1410.algo.ts:49
    // public operators = BoxMap<arc1410_OperatorKey, arc4.Byte>({ keyPrefix: 'op' }) // value = 1 authorized
    bytec 5 // "op"
    swap
    concat
    dup
    // smart_contracts/security_token/arc1410.algo.ts:126
    // if (this.operators(key).exists) {
    box_len
    bury 1
    bz arc1410_revoke_operator_after_if_else@2
    // smart_contracts/security_token/arc1410.algo.ts:127
    // this.operators(key).delete()
    frame_dig 0
    box_del
    pop

arc1410_revoke_operator_after_if_else@2:
    retsub


// smart_contracts/security_token/arc1410.algo.ts::Arc1410.arc1410_operator_transfer_by_partition(from: bytes, partition: bytes, to: bytes, amount: bytes, data: bytes) -> bytes:
arc1410_operator_transfer_by_partition:
    // smart_contracts/security_token/arc1410.algo.ts:131-138
    // @arc4.abimethod()
    // public arc1410_operator_transfer_by_partition(
    //   from: arc4.Address,
    //   partition: arc4.Address,
    //   to: arc4.Address,
    //   amount: arc4.UintN256,
    //   data: arc4.DynamicBytes,
    // ): arc4.Address {
    proto 5 1
    intc_1 // 0
    // smart_contracts/security_token/arc1410.algo.ts:139
    // const sender = new arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/security_token/arc1410.algo.ts:141
    // let authorized = this.arc1410_is_operator(from, sender, partition).native === true
    frame_dig -5
    // smart_contracts/security_token/arc1410.algo.ts:139
    // const sender = new arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/security_token/arc1410.algo.ts:141
    // let authorized = this.arc1410_is_operator(from, sender, partition).native === true
    frame_dig -4
    callsub arc1410_is_operator
    intc_1 // 0
    getbit
    intc_0 // 1
    ==
    dupn 2
    // smart_contracts/security_token/arc1410.algo.ts:143
    // if (!authorized) {
    bnz arc1410_operator_transfer_by_partition_after_if_else@4
    // smart_contracts/security_token/arc1410.algo.ts:145
    // const pKey = new arc1410_OperatorPortionKey({ holder: from, operator: sender, partition })
    frame_dig -5
    frame_dig 1
    concat
    frame_dig -4
    concat
    // smart_contracts/security_token/arc1410.algo.ts:50
    // public operatorPortionAllowances = BoxMap<arc1410_OperatorPortionKey, arc4.UintN256>({ keyPrefix: 'opa' })
    bytec 6 // "opa"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/security_token/arc1410.algo.ts:146
    // if (this.operatorPortionAllowances(pKey).exists) {
    box_len
    bury 1
    bz arc1410_operator_transfer_by_partition_after_if_else@3
    // smart_contracts/security_token/arc1410.algo.ts:147
    // const remaining = this.operatorPortionAllowances(pKey).value
    frame_dig 0
    dup
    box_get
    assert // Box must have value
    // smart_contracts/security_token/arc1410.algo.ts:148
    // assert(remaining.native >= amount.native, 'Portion allowance exceeded')
    dup
    frame_dig -2
    b>=
    assert // Portion allowance exceeded
    // smart_contracts/security_token/arc1410.algo.ts:149
    // authorized = true
    intc_0 // 1
    frame_bury 2
    // smart_contracts/security_token/arc1410.algo.ts:152
    // this.operatorPortionAllowances(pKey).value = new arc4.UintN256(remaining.native - amount.native)
    frame_dig -2
    b-
    dup
    len
    intc_2 // 32
    <=
    assert // overflow
    intc_2 // 32
    bzero
    b|
    box_put

arc1410_operator_transfer_by_partition_after_if_else@3:
    frame_dig 2
    frame_bury 3

arc1410_operator_transfer_by_partition_after_if_else@4:
    frame_dig 3
    // smart_contracts/security_token/arc1410.algo.ts:155
    // assert(authorized, 'Not authorized operator')
    assert // Not authorized operator
    // smart_contracts/security_token/arc1410.algo.ts:156
    // let receiverPartition = this._receiverPartition(to, partition)
    frame_dig -3
    frame_dig -4
    callsub _receiverPartition
    // smart_contracts/security_token/arc1410.algo.ts:157
    // this._transfer_partition(from, partition, to, receiverPartition, amount, data)
    frame_dig -5
    frame_dig -4
    frame_dig -3
    dig 3
    frame_dig -2
    frame_dig -1
    callsub _transfer_partition
    // smart_contracts/security_token/arc1410.algo.ts:158
    // return receiverPartition
    frame_bury 0
    retsub


// smart_contracts/security_token/arc1410.algo.ts::Arc1410.arc1410_can_transfer_by_partition(from: bytes, partition: bytes, to: bytes, amount: bytes, data: bytes) -> bytes:
arc1410_can_transfer_by_partition:
    // smart_contracts/security_token/arc1410.algo.ts:161-168
    // @arc4.abimethod()
    // public arc1410_can_transfer_by_partition(
    //   from: arc4.Address,
    //   partition: arc4.Address,
    //   to: arc4.Address,
    //   amount: arc4.UintN256,
    //   data: arc4.DynamicBytes,
    // ): arc1410_can_transfer_by_partition_return {
    proto 5 1
    intc_1 // 0
    dup
    pushbytes ""
    dup
    // smart_contracts/security_token/arc1410.algo.ts:238
    // return this.partitions(new arc1410_PartitionKey({ holder: holder, partition: partition })).exists
    frame_dig -5
    frame_dig -4
    concat
    // smart_contracts/security_token/arc1410.algo.ts:44
    // public partitions = BoxMap<arc1410_PartitionKey, arc4.UintN256>({ keyPrefix: 'p' })
    bytec_3 // "p"
    swap
    concat
    dup
    // smart_contracts/security_token/arc1410.algo.ts:238
    // return this.partitions(new arc1410_PartitionKey({ holder: holder, partition: partition })).exists
    box_len
    bury 1
    // smart_contracts/security_token/arc1410.algo.ts:169
    // if (!this._validPartition(from, partition)) {
    bnz arc1410_can_transfer_by_partition_after_if_else@2
    // smart_contracts/security_token/arc1410.algo.ts:170-174
    // return new arc1410_can_transfer_by_partition_return({
    //   code: new arc4.Byte(0x50),
    //   status: new arc4.Str('Partition not exists'),
    //   receiverPartition: new arc4.Address(),
    // })
    pushbytes base32(KAACGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKFAYLSORUXI2LPNYQG433UEBSXQ2LTORZQ)
    frame_bury 0
    retsub

arc1410_can_transfer_by_partition_after_if_else@2:
    // smart_contracts/security_token/arc1410.algo.ts:177
    // this.partitions(new arc1410_PartitionKey({ holder: from, partition: partition })).value.native < amount.native
    frame_dig 4
    box_get
    assert // Box must have value
    frame_dig -2
    b<
    // smart_contracts/security_token/arc1410.algo.ts:176-178
    // if (
    //   this.partitions(new arc1410_PartitionKey({ holder: from, partition: partition })).value.native < amount.native
    // ) {
    bz arc1410_can_transfer_by_partition_after_if_else@4
    // smart_contracts/security_token/arc1410.algo.ts:179-183
    // return new arc1410_can_transfer_by_partition_return({
    //   code: new arc4.Byte(0x52),
    //   status: new arc4.Str('Insufficient balance'),
    //   receiverPartition: new arc4.Address(),
    // })
    pushbytes base32(KIACGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKES3TTOVTGM2LDNFSW45BAMJQWYYLOMNSQ)
    frame_bury 0
    retsub

arc1410_can_transfer_by_partition_after_if_else@4:
    // smart_contracts/security_token/arc1410.algo.ts:186
    // if (to === new arc4.Address()) {
    frame_dig -3
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    ==
    bz arc1410_can_transfer_by_partition_after_if_else@6
    // smart_contracts/security_token/arc1410.algo.ts:187-191
    // return new arc1410_can_transfer_by_partition_return({
    //   code: new arc4.Byte(0x57),
    //   status: new arc4.Str('Invalid receiver'),
    //   receiverPartition: new arc4.Address(),
    // })
    pushbytes base32(K4ACGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIES3TWMFWGSZBAOJSWGZLJOZSXE)
    frame_bury 0
    retsub

arc1410_can_transfer_by_partition_after_if_else@6:
    // smart_contracts/security_token/arc1410.algo.ts:195
    // const senderAddr = new arc4.Address(Txn.sender)
    txn Sender
    dup
    frame_bury 0
    // smart_contracts/security_token/arc1410.algo.ts:196
    // if (senderAddr !== from) {
    frame_dig -5
    !=
    bz arc1410_can_transfer_by_partition_after_if_else@16
    // smart_contracts/security_token/arc1410.algo.ts:197
    // let authorized = this.arc1410_is_operator(from, senderAddr, partition).native === true
    frame_dig -5
    frame_dig 0
    frame_dig -4
    callsub arc1410_is_operator
    intc_1 // 0
    getbit
    intc_0 // 1
    ==
    dup
    frame_bury 2
    dup
    frame_bury 3
    // smart_contracts/security_token/arc1410.algo.ts:198
    // if (!authorized) {
    bnz arc1410_can_transfer_by_partition_after_if_else@13
    // smart_contracts/security_token/arc1410.algo.ts:199
    // const pKey = new arc1410_OperatorPortionKey({ holder: from, operator: senderAddr, partition })
    frame_dig -5
    frame_dig 0
    concat
    frame_dig -4
    concat
    // smart_contracts/security_token/arc1410.algo.ts:50
    // public operatorPortionAllowances = BoxMap<arc1410_OperatorPortionKey, arc4.UintN256>({ keyPrefix: 'opa' })
    bytec 6 // "opa"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/security_token/arc1410.algo.ts:200
    // if (this.operatorPortionAllowances(pKey).exists) {
    box_len
    bury 1
    frame_dig 2
    frame_bury 3
    bz arc1410_can_transfer_by_partition_after_if_else@13
    // smart_contracts/security_token/arc1410.algo.ts:201
    // const remaining = this.operatorPortionAllowances(pKey).value
    frame_dig 1
    box_get
    assert // Box must have value
    // smart_contracts/security_token/arc1410.algo.ts:202
    // if (remaining.native >= amount.native) {
    frame_dig -2
    b>=
    bz arc1410_can_transfer_by_partition_after_if_else@11
    // smart_contracts/security_token/arc1410.algo.ts:203
    // authorized = true
    intc_0 // 1
    frame_bury 2

arc1410_can_transfer_by_partition_after_if_else@11:
    frame_dig 2
    frame_bury 3

arc1410_can_transfer_by_partition_after_if_else@13:
    frame_dig 3
    // smart_contracts/security_token/arc1410.algo.ts:207
    // if (!authorized) {
    bnz arc1410_can_transfer_by_partition_after_if_else@16
    // smart_contracts/security_token/arc1410.algo.ts:208-212
    // return new arc1410_can_transfer_by_partition_return({
    //   code: new arc4.Byte(0x58),
    //   status: new arc4.Str('Operator not authorized'),
    //   receiverPartition: new arc4.Address(),
    // })
    pushbytes base32(LAACGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALU64DFOJQXI33SEBXG65BAMF2XI2DPOJUXUZLE)
    frame_bury 0
    retsub

arc1410_can_transfer_by_partition_after_if_else@16:
    // smart_contracts/security_token/arc1410.algo.ts:216
    // let receiverPartition = this._receiverPartition(to, partition)
    frame_dig -3
    frame_dig -4
    callsub _receiverPartition
    // smart_contracts/security_token/arc1410.algo.ts:218-222
    // return new arc1410_can_transfer_by_partition_return({
    //   code: new arc4.Byte(0x51),
    //   status: new arc4.Str('Success'),
    //   receiverPartition: receiverPartition,
    // })
    pushbytes 0x510023
    swap
    concat
    // smart_contracts/security_token/arc1410.algo.ts:220
    // status: new arc4.Str('Success'),
    pushbytes 0x000753756363657373
    // smart_contracts/security_token/arc1410.algo.ts:218-222
    // return new arc1410_can_transfer_by_partition_return({
    //   code: new arc4.Byte(0x51),
    //   status: new arc4.Str('Success'),
    //   receiverPartition: receiverPartition,
    // })
    concat
    frame_bury 0
    retsub


// smart_contracts/security_token/arc1410.algo.ts::Arc1410._receiverPartition(receiver: bytes, partition: bytes) -> bytes:
_receiverPartition:
    // smart_contracts/security_token/arc1410.algo.ts:230
    // protected _receiverPartition(receiver: arc4.Address, partition: arc4.Address): arc4.Address {
    proto 2 1
    // smart_contracts/security_token/arc1410.algo.ts:231
    // let receiverPartition = new arc4.Address()
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    // smart_contracts/security_token/arc1410.algo.ts:232
    // if (this.partitions(new arc1410_PartitionKey({ holder: receiver, partition: partition })).exists) {
    frame_dig -2
    frame_dig -1
    concat
    // smart_contracts/security_token/arc1410.algo.ts:44
    // public partitions = BoxMap<arc1410_PartitionKey, arc4.UintN256>({ keyPrefix: 'p' })
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/security_token/arc1410.algo.ts:232
    // if (this.partitions(new arc1410_PartitionKey({ holder: receiver, partition: partition })).exists) {
    box_len
    bury 1
    bz _receiverPartition_after_if_else@2
    frame_dig -1
    frame_bury 0

_receiverPartition_after_if_else@2:
    // smart_contracts/security_token/arc1410.algo.ts:235
    // return receiverPartition
    frame_dig 0
    swap
    retsub


// smart_contracts/security_token/arc1410.algo.ts::Arc1410._transfer_partition(from: bytes, fromPartition: bytes, to: bytes, toPartition: bytes, amount: bytes, data: bytes) -> void:
_transfer_partition:
    // smart_contracts/security_token/arc1410.algo.ts:305-312
    // protected _transfer_partition(
    //   from: arc4.Address,
    //   fromPartition: arc4.Address,
    //   to: arc4.Address,
    //   toPartition: arc4.Address,
    //   amount: arc4.UintN256,
    //   data: arc4.DynamicBytes,
    // ): void {
    proto 6 0
    intc_1 // 0
    dupn 6
    pushbytes ""
    dupn 4
    // smart_contracts/security_token/arc1410.algo.ts:313
    // assert(amount.native > 0, 'Invalid amount')
    frame_dig -2
    pushbytes 0x
    b>
    assert // Invalid amount
    // smart_contracts/security_token/arc1410.algo.ts:315
    // const fromKey = new arc1410_PartitionKey({ holder: from, partition: fromPartition })
    frame_dig -6
    frame_dig -5
    concat
    // smart_contracts/security_token/arc1410.algo.ts:44
    // public partitions = BoxMap<arc1410_PartitionKey, arc4.UintN256>({ keyPrefix: 'p' })
    bytec_3 // "p"
    swap
    concat
    dup
    // smart_contracts/security_token/arc1410.algo.ts:316
    // if (!this.partitions(fromKey).exists) {
    box_len
    bury 1
    bnz _transfer_partition_after_if_else@2
    // smart_contracts/security_token/arc1410.algo.ts:317
    // this.partitions(fromKey).value = new arc4.UintN256(0)
    frame_dig 12
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    box_put

_transfer_partition_after_if_else@2:
    // smart_contracts/security_token/arc1410.algo.ts:319
    // this.partitions(fromKey).value = new arc4.UintN256(this.partitions(fromKey).value.native - amount.native)
    frame_dig 12
    dup
    box_get
    assert // Box must have value
    frame_dig -2
    b-
    dup
    len
    intc_2 // 32
    <=
    assert // overflow
    intc_2 // 32
    bzero
    dup
    frame_bury 1
    b|
    box_put
    // smart_contracts/security_token/arc1410.algo.ts:324-330
    // new arc1410_partition_transfer({
    //   from: from,
    //   to: to,
    //   partition: fromPartition,
    //   amount: amount,
    //   data: data,
    // }),
    frame_dig -6
    frame_dig -4
    concat
    frame_dig -5
    concat
    frame_dig -2
    concat
    pushbytes 0x0082
    concat
    frame_dig -1
    concat
    // smart_contracts/security_token/arc1410.algo.ts:322-331
    // emit(
    //   'Transfer',
    //   new arc1410_partition_transfer({
    //     from: from,
    //     to: to,
    //     partition: fromPartition,
    //     amount: amount,
    //     data: data,
    //   }),
    // )
    pushbytes 0x0002
    swap
    concat
    pushbytes 0x206b7940 // method "Transfer((address,address,address,uint256,byte[]))"
    swap
    concat
    log
    // smart_contracts/security_token/arc1410.algo.ts:334
    // if (toPartition !== fromPartition) {
    frame_dig -3
    frame_dig -5
    !=
    bz _transfer_partition_after_if_else@4
    // smart_contracts/security_token/arc1410.algo.ts:45
    // public holderPartitionsCurrentPage = BoxMap<arc4.Address, arc4.UintN64>({ keyPrefix: 'hp_p' })
    pushbytes "hp_p"
    frame_dig -4
    concat
    dup
    frame_bury 4
    // smart_contracts/security_token/arc1410.algo.ts:253
    // if (!this.holderPartitionsCurrentPage(holder).exists) {
    box_len
    bury 1
    bnz _transfer_partition_after_if_else@9
    // smart_contracts/security_token/arc1410.algo.ts:254
    // this.holderPartitionsCurrentPage(holder).value = page
    frame_dig 4
    // smart_contracts/security_token/arc1410.algo.ts:252
    // let page = new arc4.UintN64(0)
    bytec 12 // 0x0000000000000000
    // smart_contracts/security_token/arc1410.algo.ts:254
    // this.holderPartitionsCurrentPage(holder).value = page
    box_put

_transfer_partition_after_if_else@9:
    // smart_contracts/security_token/arc1410.algo.ts:256
    // const lastPage = this.holderPartitionsCurrentPage(holder).value
    frame_dig 4
    box_get
    swap
    frame_bury 3
    assert // Box must have value
    // smart_contracts/security_token/arc1410.algo.ts:257
    // let found = false
    intc_1 // 0
    frame_bury 8
    // smart_contracts/security_token/arc1410.algo.ts:252
    // let page = new arc4.UintN64(0)
    bytec 12 // 0x0000000000000000
    // smart_contracts/security_token/arc1410.algo.ts:258
    // for (let curPage = page; curPage.native < lastPage.native; curPage = new arc4.UintN64(curPage.native + 1)) {
    frame_bury 2

_transfer_partition_while_top@10:
    // smart_contracts/security_token/arc1410.algo.ts:258
    // for (let curPage = page; curPage.native < lastPage.native; curPage = new arc4.UintN64(curPage.native + 1)) {
    frame_dig 2
    btoi
    dup
    frame_bury 10
    frame_dig 3
    btoi
    dup
    frame_bury 11
    <
    bz _transfer_partition_block@23
    // smart_contracts/security_token/arc1410.algo.ts:259-262
    // const paginatedKey = new arc1410_HoldingPartitionsPaginatedKey({
    //   holder: holder,
    //   page: curPage,
    // })
    frame_dig -4
    frame_dig 2
    concat
    // smart_contracts/security_token/arc1410.algo.ts:47
    // keyPrefix: 'hp_a',
    bytec 4 // "hp_a"
    swap
    concat
    dup
    frame_bury 6
    // smart_contracts/security_token/arc1410.algo.ts:263
    // if (!this.holderPartitionsAddresses(paginatedKey).exists) {
    box_len
    bury 1
    bnz _transfer_partition_after_if_else@13
    // smart_contracts/security_token/arc1410.algo.ts:264
    // this.holderPartitionsAddresses(paginatedKey).value = [participation]
    bytec 9 // 0x0001
    frame_dig -3
    concat
    frame_dig 6
    dup
    box_del
    pop
    swap
    box_put

_transfer_partition_after_if_else@13:
    // smart_contracts/security_token/arc1410.algo.ts:267
    // if (this.containsAddress(this.holderPartitionsAddresses(paginatedKey).value, participation)) {
    frame_dig 6
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // Box must have value
    // smart_contracts/security_token/arc1410.algo.ts:241
    // for (const v of a) {
    intc_1 // 0
    extract_uint16
    frame_bury 7
    intc_1 // 0
    frame_bury 9

_transfer_partition_for_header@14:
    // smart_contracts/security_token/arc1410.algo.ts:241
    // for (const v of a) {
    frame_dig 9
    frame_dig 7
    <
    bz _transfer_partition_after_for@18
    frame_dig 0
    extract 2 0
    frame_dig 9
    intc_2 // 32
    *
    intc_2 // 32
    extract3 // on error: Index access is out of bounds
    // smart_contracts/security_token/arc1410.algo.ts:242
    // if (v === x) return true
    frame_dig -3
    ==
    bz _transfer_partition_after_if_else@17
    intc_0 // 1

_transfer_partition_after_inlined_smart_contracts/security_token/arc1410.algo.ts::Arc1410.containsAddress@19:
    // smart_contracts/security_token/arc1410.algo.ts:267
    // if (this.containsAddress(this.holderPartitionsAddresses(paginatedKey).value, participation)) {
    bz _transfer_partition_after_if_else@21
    // smart_contracts/security_token/arc1410.algo.ts:268
    // found = true
    intc_0 // 1
    frame_bury 8

_transfer_partition_block@23:
    // smart_contracts/security_token/arc1410.algo.ts:272
    // if (!found) {
    frame_dig 8
    bnz _transfer_partition_after_if_else@4
    // smart_contracts/security_token/arc1410.algo.ts:273-276
    // const paginatedKey = new arc1410_HoldingPartitionsPaginatedKey({
    //   holder: holder,
    //   page: lastPage,
    // })
    frame_dig -4
    frame_dig 3
    concat
    // smart_contracts/security_token/arc1410.algo.ts:47
    // keyPrefix: 'hp_a',
    bytec 4 // "hp_a"
    swap
    concat
    dup
    frame_bury 5
    // smart_contracts/security_token/arc1410.algo.ts:277
    // const itemsCount = new arc4.UintN64(this.holderPartitionsAddresses(paginatedKey).value.length)
    box_get
    assert // Box must have value
    intc_1 // 0
    extract_uint16
    itob
    // smart_contracts/security_token/arc1410.algo.ts:278
    // if (itemsCount.native < 10) {
    btoi
    pushint 10 // 10
    <
    bz _transfer_partition_else_body@26
    // smart_contracts/security_token/arc1410.algo.ts:281
    // ...this.holderPartitionsAddresses(paginatedKey).value,
    frame_dig 5
    dup
    box_get
    assert // Box must have value
    // smart_contracts/security_token/arc1410.algo.ts:280-283
    // this.holderPartitionsAddresses(paginatedKey).value = [
    //   ...this.holderPartitionsAddresses(paginatedKey).value,
    //   participation,
    // ]
    extract 2 0
    // smart_contracts/security_token/arc1410.algo.ts:282
    // participation,
    bytec 9 // 0x0001
    frame_dig -3
    concat
    // smart_contracts/security_token/arc1410.algo.ts:280-283
    // this.holderPartitionsAddresses(paginatedKey).value = [
    //   ...this.holderPartitionsAddresses(paginatedKey).value,
    //   participation,
    // ]
    extract 2 0
    concat
    dup
    len
    intc_2 // 32
    /
    itob
    extract 6 2
    swap
    concat
    dig 1
    box_del
    pop
    box_put

_transfer_partition_after_if_else@4:
    // smart_contracts/security_token/arc1410.algo.ts:339
    // const toKey = new arc1410_PartitionKey({ holder: to, partition: toPartition })
    frame_dig -4
    frame_dig -3
    concat
    // smart_contracts/security_token/arc1410.algo.ts:44
    // public partitions = BoxMap<arc1410_PartitionKey, arc4.UintN256>({ keyPrefix: 'p' })
    bytec_3 // "p"
    swap
    concat
    dup
    frame_bury 6
    // smart_contracts/security_token/arc1410.algo.ts:340
    // if (!this.partitions(toKey).exists) {
    box_len
    bury 1
    bnz _transfer_partition_after_if_else@6
    // smart_contracts/security_token/arc1410.algo.ts:341
    // this.partitions(toKey).value = new arc4.UintN256(0)
    frame_dig 6
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    box_put

_transfer_partition_after_if_else@6:
    // smart_contracts/security_token/arc1410.algo.ts:343
    // this.partitions(toKey).value = new arc4.UintN256(this.partitions(toKey).value.native + amount.native)
    frame_dig 6
    dup
    box_get
    assert // Box must have value
    frame_dig -2
    b+
    dup
    len
    intc_2 // 32
    <=
    assert // overflow
    frame_dig 1
    b|
    box_put
    retsub

_transfer_partition_else_body@26:
    // smart_contracts/security_token/arc1410.algo.ts:285
    // const newLastPage = new arc4.UintN64(lastPage.native + 1)
    frame_dig 11
    intc_0 // 1
    +
    itob
    // smart_contracts/security_token/arc1410.algo.ts:286
    // this.holderPartitionsCurrentPage(holder).value = newLastPage
    frame_dig 4
    dig 1
    box_put
    // smart_contracts/security_token/arc1410.algo.ts:287-290
    // const newPaginatedKey = new arc1410_HoldingPartitionsPaginatedKey({
    //   holder: holder,
    //   page: newLastPage,
    // })
    frame_dig -4
    swap
    concat
    // smart_contracts/security_token/arc1410.algo.ts:291
    // this.holderPartitionsAddresses(newPaginatedKey).value = [participation]
    bytec 9 // 0x0001
    frame_dig -3
    concat
    // smart_contracts/security_token/arc1410.algo.ts:47
    // keyPrefix: 'hp_a',
    bytec 4 // "hp_a"
    uncover 2
    concat
    // smart_contracts/security_token/arc1410.algo.ts:291
    // this.holderPartitionsAddresses(newPaginatedKey).value = [participation]
    dup
    box_del
    pop
    swap
    box_put
    b _transfer_partition_after_if_else@4

_transfer_partition_after_if_else@21:
    // smart_contracts/security_token/arc1410.algo.ts:258
    // for (let curPage = page; curPage.native < lastPage.native; curPage = new arc4.UintN64(curPage.native + 1)) {
    frame_dig 10
    intc_0 // 1
    +
    itob
    frame_bury 2
    b _transfer_partition_while_top@10

_transfer_partition_after_if_else@17:
    frame_dig 9
    intc_0 // 1
    +
    frame_bury 9
    b _transfer_partition_for_header@14

_transfer_partition_after_for@18:
    // smart_contracts/security_token/arc1410.algo.ts:244
    // return false
    intc_1 // 0
    // smart_contracts/security_token/arc1410.algo.ts:267
    // if (this.containsAddress(this.holderPartitionsAddresses(paginatedKey).value, participation)) {
    b _transfer_partition_after_inlined_smart_contracts/security_token/arc1410.algo.ts::Arc1410.containsAddress@19


// smart_contracts/security_token/arc1410.algo.ts::Arc1410.arc1410_authorize_operator_by_portion(holder: bytes, operator: bytes, partition: bytes, amount: bytes) -> void:
arc1410_authorize_operator_by_portion:
    // smart_contracts/security_token/arc1410.algo.ts:346-352
    // @arc4.abimethod()
    // public arc1410_authorize_operator_by_portion(
    //   holder: arc4.Address,
    //   operator: arc4.Address,
    //   partition: arc4.Address,
    //   amount: arc4.UintN256,
    // ): void {
    proto 4 0
    // smart_contracts/security_token/arc1410.algo.ts:353
    // assert(new arc4.Address(Txn.sender) === holder, 'Only holder can authorize portion')
    txn Sender
    frame_dig -4
    ==
    assert // Only holder can authorize portion
    // smart_contracts/security_token/arc1410.algo.ts:354
    // const key = new arc1410_OperatorPortionKey({ holder, operator, partition })
    frame_dig -4
    frame_dig -3
    concat
    frame_dig -2
    concat
    // smart_contracts/security_token/arc1410.algo.ts:50
    // public operatorPortionAllowances = BoxMap<arc1410_OperatorPortionKey, arc4.UintN256>({ keyPrefix: 'opa' })
    bytec 6 // "opa"
    swap
    concat
    // smart_contracts/security_token/arc1410.algo.ts:355
    // this.operatorPortionAllowances(key).value = amount
    frame_dig -1
    box_put
    retsub


// smart_contracts/security_token/arc1410.algo.ts::Arc1410.arc1410_is_operator_by_portion(holder: bytes, operator: bytes, partition: bytes) -> bytes:
arc1410_is_operator_by_portion:
    // smart_contracts/security_token/arc1410.algo.ts:358-363
    // @arc4.abimethod({ readonly: true })
    // public arc1410_is_operator_by_portion(
    //   holder: arc4.Address,
    //   operator: arc4.Address,
    //   partition: arc4.Address,
    // ): arc4.Bool {
    proto 3 1
    intc_1 // 0
    // smart_contracts/security_token/arc1410.algo.ts:364
    // if (operator === holder) return new arc4.Bool(true)
    frame_dig -2
    frame_dig -3
    ==
    bz arc1410_is_operator_by_portion_after_if_else@2
    bytec_2 // 0x80
    swap
    retsub

arc1410_is_operator_by_portion_after_if_else@2:
    // smart_contracts/security_token/arc1410.algo.ts:365
    // const key = new arc1410_OperatorPortionKey({ holder, operator, partition })
    frame_dig -3
    frame_dig -2
    concat
    frame_dig -1
    concat
    // smart_contracts/security_token/arc1410.algo.ts:50
    // public operatorPortionAllowances = BoxMap<arc1410_OperatorPortionKey, arc4.UintN256>({ keyPrefix: 'opa' })
    bytec 6 // "opa"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/security_token/arc1410.algo.ts:366
    // if (!this.operatorPortionAllowances(key).exists) return new arc4.Bool(false)
    box_len
    bury 1
    bnz arc1410_is_operator_by_portion_after_if_else@4
    bytec 8 // 0x00
    swap
    retsub

arc1410_is_operator_by_portion_after_if_else@4:
    // smart_contracts/security_token/arc1410.algo.ts:367
    // return new arc4.Bool(this.operatorPortionAllowances(key).value.native > 0)
    frame_dig 0
    box_get
    assert // Box must have value
    pushbytes 0x
    b>
    bytec 8 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    swap
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.bootstrap(name: bytes, symbol: bytes, decimals: bytes, totalSupply: bytes) -> bytes:
bootstrap:
    // smart_contracts/security_token/arc200.algo.ts:65-66
    // @arc4.abimethod()
    // public bootstrap(name: DynamicBytes, symbol: DynamicBytes, decimals: UintN8, totalSupply: UintN256): Bool {
    proto 4 1
    // smart_contracts/security_token/arc200.algo.ts:67
    // assert(Txn.sender === Global.creatorAddress, 'Only deployer of this smart contract can call bootstrap method')
    txn Sender
    global CreatorAddress
    ==
    assert // Only deployer of this smart contract can call bootstrap method
    // smart_contracts/security_token/arc200.algo.ts:68
    // assert(name.native.length > 0, 'Name of the asset must be longer or equal to 1 character')
    frame_dig -4
    extract 2 0
    len
    dup
    assert // Name of the asset must be longer or equal to 1 character
    // smart_contracts/security_token/arc200.algo.ts:69
    // assert(name.native.length <= 32, 'Name of the asset must be shorter or equal to 32 characters')
    intc_2 // 32
    <=
    assert // Name of the asset must be shorter or equal to 32 characters
    // smart_contracts/security_token/arc200.algo.ts:70
    // assert(symbol.native.length > 0, 'Symbol of the asset must be longer or equal to 1 character')
    frame_dig -3
    extract 2 0
    len
    dup
    assert // Symbol of the asset must be longer or equal to 1 character
    // smart_contracts/security_token/arc200.algo.ts:71
    // assert(symbol.native.length <= 8, 'Symbol of the asset must be shorter or equal to 8 characters')
    intc_3 // 8
    <=
    assert // Symbol of the asset must be shorter or equal to 8 characters
    // smart_contracts/security_token/arc200.algo.ts:60
    // public totalSupply = GlobalState<UintN256>({ key: 't' })
    intc_1 // 0
    bytec 10 // "t"
    // smart_contracts/security_token/arc200.algo.ts:72
    // assert(!this.totalSupply.hasValue, 'This method can be called only once')
    app_global_get_ex
    bury 1
    !
    assert // This method can be called only once
    // smart_contracts/security_token/arc200.algo.ts:48
    // public name = GlobalState<DynamicBytes>({ key: 'n' })
    pushbytes "n"
    // smart_contracts/security_token/arc200.algo.ts:74
    // this.name.value = name
    frame_dig -4
    app_global_put
    // smart_contracts/security_token/arc200.algo.ts:52
    // public symbol = GlobalState<DynamicBytes>({ key: 's' })
    pushbytes "s"
    // smart_contracts/security_token/arc200.algo.ts:75
    // this.symbol.value = symbol
    frame_dig -3
    app_global_put
    // smart_contracts/security_token/arc200.algo.ts:60
    // public totalSupply = GlobalState<UintN256>({ key: 't' })
    bytec 10 // "t"
    // smart_contracts/security_token/arc200.algo.ts:76
    // this.totalSupply.value = totalSupply
    frame_dig -1
    app_global_put
    // smart_contracts/security_token/arc200.algo.ts:56
    // public decimals = GlobalState<UintN8>({ key: 'd' })
    pushbytes "d"
    // smart_contracts/security_token/arc200.algo.ts:77
    // this.decimals.value = decimals
    frame_dig -2
    app_global_put
    // smart_contracts/security_token/arc200.algo.ts:78
    // const sender = new Address(Txn.sender)
    txn Sender
    // smart_contracts/security_token/arc200.algo.ts:62
    // public balances = BoxMap<Address, UintN256>({ keyPrefix: 'b' })
    bytec 7 // "b"
    dig 1
    concat
    // smart_contracts/security_token/arc200.algo.ts:80
    // this.balances(sender).value = totalSupply
    frame_dig -1
    box_put
    // smart_contracts/security_token/arc200.algo.ts:82
    // emit(new arc200_Transfer({ from: new Address(Global.zeroAddress), to: sender, value: totalSupply }))
    global ZeroAddress
    swap
    concat
    frame_dig -1
    concat
    bytec 13 // method "arc200_Transfer(address,address,uint256)"
    swap
    concat
    log
    // smart_contracts/security_token/arc200.algo.ts:83
    // return new Bool(true)
    bytec_2 // 0x80
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_name() -> bytes:
arc200_name:
    // smart_contracts/security_token/arc200.algo.ts:48
    // public name = GlobalState<DynamicBytes>({ key: 'n' })
    intc_1 // 0
    pushbytes "n"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc200.algo.ts:93
    // return new StaticBytes<32>(this.name.value.native)
    extract 2 0
    dup
    len
    intc_2 // 32
    ==
    assert // invalid size
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_symbol() -> bytes:
arc200_symbol:
    // smart_contracts/security_token/arc200.algo.ts:52
    // public symbol = GlobalState<DynamicBytes>({ key: 's' })
    intc_1 // 0
    pushbytes "s"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc200.algo.ts:103
    // return new StaticBytes<8>(this.symbol.value.native)
    extract 2 0
    dup
    len
    intc_3 // 8
    ==
    assert // invalid size
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_decimals() -> bytes:
arc200_decimals:
    // smart_contracts/security_token/arc200.algo.ts:56
    // public decimals = GlobalState<UintN8>({ key: 'd' })
    intc_1 // 0
    pushbytes "d"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc200.algo.ts:113
    // return this.decimals.value
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_totalSupply() -> bytes:
arc200_totalSupply:
    // smart_contracts/security_token/arc200.algo.ts:60
    // public totalSupply = GlobalState<UintN256>({ key: 't' })
    intc_1 // 0
    bytec 10 // "t"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/security_token/arc200.algo.ts:123
    // return this.totalSupply.value
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_balanceOf(owner: bytes) -> bytes:
arc200_balanceOf:
    // smart_contracts/security_token/arc200.algo.ts:132-133
    // @arc4.abimethod({ readonly: true })
    // public arc200_balanceOf(owner: Address): arc4.UintN256 {
    proto 1 1
    // smart_contracts/security_token/arc200.algo.ts:134
    // return this._balanceOf(owner)
    frame_dig -1
    callsub _balanceOf
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_transferFrom(from: bytes, to: bytes, value: bytes) -> bytes:
arc200_transferFrom:
    // smart_contracts/security_token/arc200.algo.ts:157-158
    // @arc4.abimethod()
    // public arc200_transferFrom(from: Address, to: Address, value: arc4.UintN256): arc4.Bool {
    proto 3 1
    // smart_contracts/security_token/arc200.algo.ts:159
    // const spender = new Address(Txn.sender)
    txn Sender
    // smart_contracts/security_token/arc200.algo.ts:160
    // const spender_allowance = this._allowance(from, spender)
    frame_dig -3
    dig 1
    callsub _allowance
    // smart_contracts/security_token/arc200.algo.ts:161
    // assert(spender_allowance.native >= value.native, 'insufficient approval')
    dup
    frame_dig -1
    b>=
    assert // insufficient approval
    // smart_contracts/security_token/arc200.algo.ts:162
    // const new_spender_allowance = new UintN256(spender_allowance.native - value.native)
    frame_dig -1
    b-
    dup
    len
    intc_2 // 32
    <=
    assert // overflow
    intc_2 // 32
    bzero
    b|
    // smart_contracts/security_token/arc200.algo.ts:163
    // this._approve(from, spender, new_spender_allowance)
    frame_dig -3
    cover 2
    callsub _approve
    pop
    // smart_contracts/security_token/arc200.algo.ts:164
    // return this._transfer(from, to, value)
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub _transfer
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_approve(spender: bytes, value: bytes) -> bytes:
arc200_approve:
    // smart_contracts/security_token/arc200.algo.ts:174-175
    // @arc4.abimethod()
    // public arc200_approve(spender: Address, value: arc4.UintN256): Bool {
    proto 2 1
    // smart_contracts/security_token/arc200.algo.ts:176
    // const owner = new Address(Txn.sender)
    txn Sender
    // smart_contracts/security_token/arc200.algo.ts:177
    // return this._approve(owner, spender, value)
    frame_dig -2
    frame_dig -1
    callsub _approve
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200.arc200_allowance(owner: bytes, spender: bytes) -> bytes:
arc200_allowance:
    // smart_contracts/security_token/arc200.algo.ts:186-187
    // @arc4.abimethod({ readonly: true })
    // public arc200_allowance(owner: Address, spender: Address): arc4.UintN256 {
    proto 2 1
    // smart_contracts/security_token/arc200.algo.ts:188
    // return this._allowance(owner, spender)
    frame_dig -2
    frame_dig -1
    callsub _allowance
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200._balanceOf(owner: bytes) -> bytes:
_balanceOf:
    // smart_contracts/security_token/arc200.algo.ts:191
    // protected _balanceOf(owner: Address): UintN256 {
    proto 1 1
    // smart_contracts/security_token/arc200.algo.ts:62
    // public balances = BoxMap<Address, UintN256>({ keyPrefix: 'b' })
    bytec 7 // "b"
    frame_dig -1
    concat
    dup
    // smart_contracts/security_token/arc200.algo.ts:192
    // if (!this.balances(owner).exists) return new UintN256(0)
    box_len
    bury 1
    bnz _balanceOf_after_if_else@2
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    swap
    retsub

_balanceOf_after_if_else@2:
    // smart_contracts/security_token/arc200.algo.ts:193
    // return this.balances(owner).value
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200._transfer(sender: bytes, recipient: bytes, amount: bytes) -> bytes:
_transfer:
    // smart_contracts/security_token/arc200.algo.ts:196
    // protected _transfer(sender: Address, recipient: Address, amount: UintN256): Bool {
    proto 3 1
    // smart_contracts/security_token/arc200.algo.ts:197
    // const sender_balance = this._balanceOf(sender)
    frame_dig -3
    callsub _balanceOf
    dup
    // smart_contracts/security_token/arc200.algo.ts:198
    // const recipient_balance = this._balanceOf(recipient)
    frame_dig -2
    callsub _balanceOf
    swap
    // smart_contracts/security_token/arc200.algo.ts:199
    // assert(sender_balance.native >= amount.native, 'Insufficient balance at the sender account')
    frame_dig -1
    b>=
    assert // Insufficient balance at the sender account
    // smart_contracts/security_token/arc200.algo.ts:201
    // if (sender !== recipient) {
    frame_dig -3
    frame_dig -2
    !=
    bz _transfer_after_if_else@2
    // smart_contracts/security_token/arc200.algo.ts:203
    // this.balances(sender).value = new UintN256(sender_balance.native - amount.native)
    frame_dig 0
    frame_dig -1
    b-
    dup
    len
    intc_2 // 32
    <=
    assert // overflow
    intc_2 // 32
    bzero
    swap
    dig 1
    b|
    // smart_contracts/security_token/arc200.algo.ts:62
    // public balances = BoxMap<Address, UintN256>({ keyPrefix: 'b' })
    bytec 7 // "b"
    frame_dig -3
    concat
    // smart_contracts/security_token/arc200.algo.ts:203
    // this.balances(sender).value = new UintN256(sender_balance.native - amount.native)
    swap
    box_put
    // smart_contracts/security_token/arc200.algo.ts:204
    // this.balances(recipient).value = new UintN256(recipient_balance.native + amount.native)
    frame_dig 1
    frame_dig -1
    b+
    dup
    len
    intc_2 // 32
    <=
    assert // overflow
    b|
    // smart_contracts/security_token/arc200.algo.ts:62
    // public balances = BoxMap<Address, UintN256>({ keyPrefix: 'b' })
    bytec 7 // "b"
    frame_dig -2
    concat
    // smart_contracts/security_token/arc200.algo.ts:204
    // this.balances(recipient).value = new UintN256(recipient_balance.native + amount.native)
    swap
    box_put

_transfer_after_if_else@2:
    // smart_contracts/security_token/arc200.algo.ts:206
    // emit(new arc200_Transfer({ from: sender, to: recipient, value: amount }))
    frame_dig -3
    frame_dig -2
    concat
    frame_dig -1
    concat
    bytec 13 // method "arc200_Transfer(address,address,uint256)"
    swap
    concat
    log
    // smart_contracts/security_token/arc200.algo.ts:207
    // return new Bool(true)
    bytec_2 // 0x80
    frame_bury 0
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200._approvalKey(owner: bytes, spender: bytes) -> bytes:
_approvalKey:
    // smart_contracts/security_token/arc200.algo.ts:209
    // protected _approvalKey(owner: Address, spender: Address): StaticBytes<32> {
    proto 2 1
    // smart_contracts/security_token/arc200.algo.ts:210
    // return new StaticBytes<32>(op.sha256(op.concat(owner.bytes, spender.bytes)))
    frame_dig -2
    frame_dig -1
    concat
    sha256
    dup
    len
    intc_2 // 32
    ==
    assert // invalid size
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200._allowance(owner: bytes, spender: bytes) -> bytes:
_allowance:
    // smart_contracts/security_token/arc200.algo.ts:213
    // protected _allowance(owner: Address, spender: Address): UintN256 {
    proto 2 1
    // smart_contracts/security_token/arc200.algo.ts:214
    // const key = this._approvalKey(owner, spender)
    frame_dig -2
    frame_dig -1
    callsub _approvalKey
    // smart_contracts/security_token/arc200.algo.ts:64
    // public approvals = BoxMap<StaticBytes<32>, ApprovalStruct>({ keyPrefix: 'a' })
    pushbytes "a"
    swap
    concat
    dup
    // smart_contracts/security_token/arc200.algo.ts:215
    // if (!this.approvals(key).exists) return new UintN256(0)
    box_len
    bury 1
    bnz _allowance_after_if_else@2
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    swap
    retsub

_allowance_after_if_else@2:
    // smart_contracts/security_token/arc200.algo.ts:216
    // return this.approvals(key).value.approvalAmount
    frame_dig 0
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    swap
    retsub


// smart_contracts/security_token/arc200.algo.ts::Arc200._approve(owner: bytes, spender: bytes, amount: bytes) -> bytes:
_approve:
    // smart_contracts/security_token/arc200.algo.ts:219
    // protected _approve(owner: Address, spender: Address, amount: UintN256): Bool {
    proto 3 1
    // smart_contracts/security_token/arc200.algo.ts:220
    // const key = this._approvalKey(owner, spender)
    frame_dig -3
    frame_dig -2
    callsub _approvalKey
    // smart_contracts/security_token/arc200.algo.ts:221-225
    // const approvalBox: ApprovalStruct = new ApprovalStruct({
    //   approvalAmount: amount,
    //   owner: owner,
    //   spender: spender,
    // })
    frame_dig -1
    frame_dig -3
    concat
    frame_dig -2
    concat
    // smart_contracts/security_token/arc200.algo.ts:64
    // public approvals = BoxMap<StaticBytes<32>, ApprovalStruct>({ keyPrefix: 'a' })
    pushbytes "a"
    uncover 2
    concat
    // smart_contracts/security_token/arc200.algo.ts:226
    // this.approvals(key).value = approvalBox.copy()
    swap
    box_put
    // smart_contracts/security_token/arc200.algo.ts:227
    // emit(new arc200_Approval({ owner: owner, spender: spender, value: amount }))
    frame_dig -3
    frame_dig -2
    concat
    frame_dig -1
    concat
    pushbytes 0x1969f865 // method "arc200_Approval(address,address,uint256)"
    swap
    concat
    log
    // smart_contracts/security_token/arc200.algo.ts:228
    // return new Bool(true)
    bytec_2 // 0x80
    retsub
